Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> construct
Rule 2     construct -> funcdef construct
Rule 3     construct -> statement construct
Rule 4     construct -> statement
Rule 5     construct -> funcdef
Rule 6     statement_suite -> TAB statement
Rule 7     statement_suite -> TAB statement statement_suite
Rule 8     statement -> return_stmt
Rule 9     statement -> assignment_stmt
Rule 10    statement -> func_call_stmt
Rule 11    statement -> loop_stmt
Rule 12    statement -> if_stmt
Rule 13    statement -> PASS
Rule 14    loop_stmt -> for_loop
Rule 15    for_loop -> FOR IDENTIFIER IN IDENTIFIER COLON statement_suite
Rule 16    if_stmt -> IF LPAREN arithmetic_expr RPAREN COLON statement_suite
Rule 17    if_stmt -> IF LPAREN arithmetic_expr RPAREN COLON statement_suite elif_stmt
Rule 18    elif_stmt -> ELIF LPAREN arithmetic_expr RPAREN COLON statement_suite else_stmt
Rule 19    elif_stmt -> else_stmt
Rule 20    else_stmt -> ELSE COLON statement_suite
Rule 21    funcdef -> DEF IDENTIFIER LPAREN parameters RPAREN COLON statement_suite
Rule 22    funcdef -> DEF IDENTIFIER LPAREN RPAREN COLON statement_suite
Rule 23    parameters -> atom
Rule 24    parameters -> atom COMMA parameters
Rule 25    parameters -> empty
Rule 26    func_call_stmt -> IDENTIFIER LPAREN parameters RPAREN
Rule 27    assignment_stmt -> IDENTIFIER EQUALS expression
Rule 28    expression -> arithmetic_expr
Rule 29    expression -> func_call_stmt
Rule 30    arithmetic_expr -> arithmetic_expr arithmetic_op arithmetic_expr
Rule 31    arithmetic_expr -> atom
Rule 32    return_stmt -> RETURN expression
Rule 33    atom -> IDENTIFIER
Rule 34    atom -> literal
Rule 35    literal -> NUMBER
Rule 36    literal -> NONE
Rule 37    literal -> TRUE
Rule 38    literal -> FALSE
Rule 39    literal -> STRING
Rule 40    literal -> list
Rule 41    list -> LSQUARE parameters RSQUARE
Rule 42    arithmetic_op -> PLUS
Rule 43    arithmetic_op -> MINUS
Rule 44    arithmetic_op -> MODULUS
Rule 45    arithmetic_op -> DIVIDE
Rule 46    arithmetic_op -> MULTIPLY
Rule 47    arithmetic_op -> GR
Rule 48    arithmetic_op -> LE
Rule 49    arithmetic_op -> EQ
Rule 50    arithmetic_op -> GREQ
Rule 51    arithmetic_op -> LEEQ
Rule 52    empty -> <empty>

Terminals, with rules where they appear

COLON                : 15 16 17 18 20 21 22
COMMA                : 24
DEF                  : 21 22
DIVIDE               : 45
ELIF                 : 18
ELSE                 : 20
EQ                   : 49
EQUALS               : 27
FALSE                : 38
FOR                  : 15
GR                   : 47
GREQ                 : 50
IDENTIFIER           : 15 15 21 22 26 27 33
IF                   : 16 17
IN                   : 15
LE                   : 48
LEEQ                 : 51
LPAREN               : 16 17 18 21 22 26
LSQUARE              : 41
MINUS                : 43
MODULUS              : 44
MULTIPLY             : 46
NONE                 : 36
NUMBER               : 35
PASS                 : 13
PLUS                 : 42
RETURN               : 32
RPAREN               : 16 17 18 21 22 26
RSQUARE              : 41
STRING               : 39
TAB                  : 6 7
TRUE                 : 37
error                : 

Nonterminals, with rules where they appear

arithmetic_expr      : 16 17 18 28 30 30
arithmetic_op        : 30
assignment_stmt      : 9
atom                 : 23 24 31
construct            : 1 2 3
elif_stmt            : 17
else_stmt            : 18 19
empty                : 25
expression           : 27 32
for_loop             : 14
func_call_stmt       : 10 29
funcdef              : 2 5
if_stmt              : 12
list                 : 40
literal              : 34
loop_stmt            : 11
parameters           : 21 24 26 41
return_stmt          : 8
start                : 0
statement            : 3 4 6 7
statement_suite      : 7 15 16 17 18 20 21 22

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . construct
    (2) construct -> . funcdef construct
    (3) construct -> . statement construct
    (4) construct -> . statement
    (5) construct -> . funcdef
    (21) funcdef -> . DEF IDENTIFIER LPAREN parameters RPAREN COLON statement_suite
    (22) funcdef -> . DEF IDENTIFIER LPAREN RPAREN COLON statement_suite
    (8) statement -> . return_stmt
    (9) statement -> . assignment_stmt
    (10) statement -> . func_call_stmt
    (11) statement -> . loop_stmt
    (12) statement -> . if_stmt
    (13) statement -> . PASS
    (32) return_stmt -> . RETURN expression
    (27) assignment_stmt -> . IDENTIFIER EQUALS expression
    (26) func_call_stmt -> . IDENTIFIER LPAREN parameters RPAREN
    (14) loop_stmt -> . for_loop
    (16) if_stmt -> . IF LPAREN arithmetic_expr RPAREN COLON statement_suite
    (17) if_stmt -> . IF LPAREN arithmetic_expr RPAREN COLON statement_suite elif_stmt
    (15) for_loop -> . FOR IDENTIFIER IN IDENTIFIER COLON statement_suite

    DEF             shift and go to state 5
    PASS            shift and go to state 12
    RETURN          shift and go to state 13
    IDENTIFIER      shift and go to state 6
    IF              shift and go to state 15
    FOR             shift and go to state 16

    start                          shift and go to state 1
    construct                      shift and go to state 2
    funcdef                        shift and go to state 3
    statement                      shift and go to state 4
    return_stmt                    shift and go to state 7
    assignment_stmt                shift and go to state 8
    func_call_stmt                 shift and go to state 9
    loop_stmt                      shift and go to state 10
    if_stmt                        shift and go to state 11
    for_loop                       shift and go to state 14

state 1

    (0) S' -> start .



state 2

    (1) start -> construct .

    $end            reduce using rule 1 (start -> construct .)


state 3

    (2) construct -> funcdef . construct
    (5) construct -> funcdef .
    (2) construct -> . funcdef construct
    (3) construct -> . statement construct
    (4) construct -> . statement
    (5) construct -> . funcdef
    (21) funcdef -> . DEF IDENTIFIER LPAREN parameters RPAREN COLON statement_suite
    (22) funcdef -> . DEF IDENTIFIER LPAREN RPAREN COLON statement_suite
    (8) statement -> . return_stmt
    (9) statement -> . assignment_stmt
    (10) statement -> . func_call_stmt
    (11) statement -> . loop_stmt
    (12) statement -> . if_stmt
    (13) statement -> . PASS
    (32) return_stmt -> . RETURN expression
    (27) assignment_stmt -> . IDENTIFIER EQUALS expression
    (26) func_call_stmt -> . IDENTIFIER LPAREN parameters RPAREN
    (14) loop_stmt -> . for_loop
    (16) if_stmt -> . IF LPAREN arithmetic_expr RPAREN COLON statement_suite
    (17) if_stmt -> . IF LPAREN arithmetic_expr RPAREN COLON statement_suite elif_stmt
    (15) for_loop -> . FOR IDENTIFIER IN IDENTIFIER COLON statement_suite

    $end            reduce using rule 5 (construct -> funcdef .)
    DEF             shift and go to state 5
    PASS            shift and go to state 12
    RETURN          shift and go to state 13
    IDENTIFIER      shift and go to state 6
    IF              shift and go to state 15
    FOR             shift and go to state 16

    funcdef                        shift and go to state 3
    construct                      shift and go to state 17
    statement                      shift and go to state 4
    return_stmt                    shift and go to state 7
    assignment_stmt                shift and go to state 8
    func_call_stmt                 shift and go to state 9
    loop_stmt                      shift and go to state 10
    if_stmt                        shift and go to state 11
    for_loop                       shift and go to state 14

state 4

    (3) construct -> statement . construct
    (4) construct -> statement .
    (2) construct -> . funcdef construct
    (3) construct -> . statement construct
    (4) construct -> . statement
    (5) construct -> . funcdef
    (21) funcdef -> . DEF IDENTIFIER LPAREN parameters RPAREN COLON statement_suite
    (22) funcdef -> . DEF IDENTIFIER LPAREN RPAREN COLON statement_suite
    (8) statement -> . return_stmt
    (9) statement -> . assignment_stmt
    (10) statement -> . func_call_stmt
    (11) statement -> . loop_stmt
    (12) statement -> . if_stmt
    (13) statement -> . PASS
    (32) return_stmt -> . RETURN expression
    (27) assignment_stmt -> . IDENTIFIER EQUALS expression
    (26) func_call_stmt -> . IDENTIFIER LPAREN parameters RPAREN
    (14) loop_stmt -> . for_loop
    (16) if_stmt -> . IF LPAREN arithmetic_expr RPAREN COLON statement_suite
    (17) if_stmt -> . IF LPAREN arithmetic_expr RPAREN COLON statement_suite elif_stmt
    (15) for_loop -> . FOR IDENTIFIER IN IDENTIFIER COLON statement_suite

    $end            reduce using rule 4 (construct -> statement .)
    DEF             shift and go to state 5
    PASS            shift and go to state 12
    RETURN          shift and go to state 13
    IDENTIFIER      shift and go to state 6
    IF              shift and go to state 15
    FOR             shift and go to state 16

    statement                      shift and go to state 4
    construct                      shift and go to state 18
    funcdef                        shift and go to state 3
    return_stmt                    shift and go to state 7
    assignment_stmt                shift and go to state 8
    func_call_stmt                 shift and go to state 9
    loop_stmt                      shift and go to state 10
    if_stmt                        shift and go to state 11
    for_loop                       shift and go to state 14

state 5

    (21) funcdef -> DEF . IDENTIFIER LPAREN parameters RPAREN COLON statement_suite
    (22) funcdef -> DEF . IDENTIFIER LPAREN RPAREN COLON statement_suite

    IDENTIFIER      shift and go to state 19


state 6

    (27) assignment_stmt -> IDENTIFIER . EQUALS expression
    (26) func_call_stmt -> IDENTIFIER . LPAREN parameters RPAREN

    EQUALS          shift and go to state 20
    LPAREN          shift and go to state 21


state 7

    (8) statement -> return_stmt .

    DEF             reduce using rule 8 (statement -> return_stmt .)
    PASS            reduce using rule 8 (statement -> return_stmt .)
    RETURN          reduce using rule 8 (statement -> return_stmt .)
    IDENTIFIER      reduce using rule 8 (statement -> return_stmt .)
    IF              reduce using rule 8 (statement -> return_stmt .)
    FOR             reduce using rule 8 (statement -> return_stmt .)
    $end            reduce using rule 8 (statement -> return_stmt .)
    TAB             reduce using rule 8 (statement -> return_stmt .)
    ELIF            reduce using rule 8 (statement -> return_stmt .)
    ELSE            reduce using rule 8 (statement -> return_stmt .)


state 8

    (9) statement -> assignment_stmt .

    DEF             reduce using rule 9 (statement -> assignment_stmt .)
    PASS            reduce using rule 9 (statement -> assignment_stmt .)
    RETURN          reduce using rule 9 (statement -> assignment_stmt .)
    IDENTIFIER      reduce using rule 9 (statement -> assignment_stmt .)
    IF              reduce using rule 9 (statement -> assignment_stmt .)
    FOR             reduce using rule 9 (statement -> assignment_stmt .)
    $end            reduce using rule 9 (statement -> assignment_stmt .)
    TAB             reduce using rule 9 (statement -> assignment_stmt .)
    ELIF            reduce using rule 9 (statement -> assignment_stmt .)
    ELSE            reduce using rule 9 (statement -> assignment_stmt .)


state 9

    (10) statement -> func_call_stmt .

    DEF             reduce using rule 10 (statement -> func_call_stmt .)
    PASS            reduce using rule 10 (statement -> func_call_stmt .)
    RETURN          reduce using rule 10 (statement -> func_call_stmt .)
    IDENTIFIER      reduce using rule 10 (statement -> func_call_stmt .)
    IF              reduce using rule 10 (statement -> func_call_stmt .)
    FOR             reduce using rule 10 (statement -> func_call_stmt .)
    $end            reduce using rule 10 (statement -> func_call_stmt .)
    TAB             reduce using rule 10 (statement -> func_call_stmt .)
    ELIF            reduce using rule 10 (statement -> func_call_stmt .)
    ELSE            reduce using rule 10 (statement -> func_call_stmt .)


state 10

    (11) statement -> loop_stmt .

    DEF             reduce using rule 11 (statement -> loop_stmt .)
    PASS            reduce using rule 11 (statement -> loop_stmt .)
    RETURN          reduce using rule 11 (statement -> loop_stmt .)
    IDENTIFIER      reduce using rule 11 (statement -> loop_stmt .)
    IF              reduce using rule 11 (statement -> loop_stmt .)
    FOR             reduce using rule 11 (statement -> loop_stmt .)
    $end            reduce using rule 11 (statement -> loop_stmt .)
    TAB             reduce using rule 11 (statement -> loop_stmt .)
    ELIF            reduce using rule 11 (statement -> loop_stmt .)
    ELSE            reduce using rule 11 (statement -> loop_stmt .)


state 11

    (12) statement -> if_stmt .

    DEF             reduce using rule 12 (statement -> if_stmt .)
    PASS            reduce using rule 12 (statement -> if_stmt .)
    RETURN          reduce using rule 12 (statement -> if_stmt .)
    IDENTIFIER      reduce using rule 12 (statement -> if_stmt .)
    IF              reduce using rule 12 (statement -> if_stmt .)
    FOR             reduce using rule 12 (statement -> if_stmt .)
    $end            reduce using rule 12 (statement -> if_stmt .)
    TAB             reduce using rule 12 (statement -> if_stmt .)
    ELIF            reduce using rule 12 (statement -> if_stmt .)
    ELSE            reduce using rule 12 (statement -> if_stmt .)


state 12

    (13) statement -> PASS .

    DEF             reduce using rule 13 (statement -> PASS .)
    PASS            reduce using rule 13 (statement -> PASS .)
    RETURN          reduce using rule 13 (statement -> PASS .)
    IDENTIFIER      reduce using rule 13 (statement -> PASS .)
    IF              reduce using rule 13 (statement -> PASS .)
    FOR             reduce using rule 13 (statement -> PASS .)
    $end            reduce using rule 13 (statement -> PASS .)
    TAB             reduce using rule 13 (statement -> PASS .)
    ELIF            reduce using rule 13 (statement -> PASS .)
    ELSE            reduce using rule 13 (statement -> PASS .)


state 13

    (32) return_stmt -> RETURN . expression
    (28) expression -> . arithmetic_expr
    (29) expression -> . func_call_stmt
    (30) arithmetic_expr -> . arithmetic_expr arithmetic_op arithmetic_expr
    (31) arithmetic_expr -> . atom
    (26) func_call_stmt -> . IDENTIFIER LPAREN parameters RPAREN
    (33) atom -> . IDENTIFIER
    (34) atom -> . literal
    (35) literal -> . NUMBER
    (36) literal -> . NONE
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . STRING
    (40) literal -> . list
    (41) list -> . LSQUARE parameters RSQUARE

    IDENTIFIER      shift and go to state 26
    NUMBER          shift and go to state 28
    NONE            shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    STRING          shift and go to state 32
    LSQUARE         shift and go to state 34

    expression                     shift and go to state 22
    arithmetic_expr                shift and go to state 23
    func_call_stmt                 shift and go to state 24
    atom                           shift and go to state 25
    literal                        shift and go to state 27
    list                           shift and go to state 33

state 14

    (14) loop_stmt -> for_loop .

    DEF             reduce using rule 14 (loop_stmt -> for_loop .)
    PASS            reduce using rule 14 (loop_stmt -> for_loop .)
    RETURN          reduce using rule 14 (loop_stmt -> for_loop .)
    IDENTIFIER      reduce using rule 14 (loop_stmt -> for_loop .)
    IF              reduce using rule 14 (loop_stmt -> for_loop .)
    FOR             reduce using rule 14 (loop_stmt -> for_loop .)
    $end            reduce using rule 14 (loop_stmt -> for_loop .)
    TAB             reduce using rule 14 (loop_stmt -> for_loop .)
    ELIF            reduce using rule 14 (loop_stmt -> for_loop .)
    ELSE            reduce using rule 14 (loop_stmt -> for_loop .)


state 15

    (16) if_stmt -> IF . LPAREN arithmetic_expr RPAREN COLON statement_suite
    (17) if_stmt -> IF . LPAREN arithmetic_expr RPAREN COLON statement_suite elif_stmt

    LPAREN          shift and go to state 35


state 16

    (15) for_loop -> FOR . IDENTIFIER IN IDENTIFIER COLON statement_suite

    IDENTIFIER      shift and go to state 36


state 17

    (2) construct -> funcdef construct .

    $end            reduce using rule 2 (construct -> funcdef construct .)


state 18

    (3) construct -> statement construct .

    $end            reduce using rule 3 (construct -> statement construct .)


state 19

    (21) funcdef -> DEF IDENTIFIER . LPAREN parameters RPAREN COLON statement_suite
    (22) funcdef -> DEF IDENTIFIER . LPAREN RPAREN COLON statement_suite

    LPAREN          shift and go to state 37


state 20

    (27) assignment_stmt -> IDENTIFIER EQUALS . expression
    (28) expression -> . arithmetic_expr
    (29) expression -> . func_call_stmt
    (30) arithmetic_expr -> . arithmetic_expr arithmetic_op arithmetic_expr
    (31) arithmetic_expr -> . atom
    (26) func_call_stmt -> . IDENTIFIER LPAREN parameters RPAREN
    (33) atom -> . IDENTIFIER
    (34) atom -> . literal
    (35) literal -> . NUMBER
    (36) literal -> . NONE
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . STRING
    (40) literal -> . list
    (41) list -> . LSQUARE parameters RSQUARE

    IDENTIFIER      shift and go to state 26
    NUMBER          shift and go to state 28
    NONE            shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    STRING          shift and go to state 32
    LSQUARE         shift and go to state 34

    expression                     shift and go to state 38
    arithmetic_expr                shift and go to state 23
    func_call_stmt                 shift and go to state 24
    atom                           shift and go to state 25
    literal                        shift and go to state 27
    list                           shift and go to state 33

state 21

    (26) func_call_stmt -> IDENTIFIER LPAREN . parameters RPAREN
    (23) parameters -> . atom
    (24) parameters -> . atom COMMA parameters
    (25) parameters -> . empty
    (33) atom -> . IDENTIFIER
    (34) atom -> . literal
    (52) empty -> .
    (35) literal -> . NUMBER
    (36) literal -> . NONE
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . STRING
    (40) literal -> . list
    (41) list -> . LSQUARE parameters RSQUARE

    IDENTIFIER      shift and go to state 39
    RPAREN          reduce using rule 52 (empty -> .)
    NUMBER          shift and go to state 28
    NONE            shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    STRING          shift and go to state 32
    LSQUARE         shift and go to state 34

    parameters                     shift and go to state 40
    atom                           shift and go to state 41
    empty                          shift and go to state 42
    literal                        shift and go to state 27
    list                           shift and go to state 33

state 22

    (32) return_stmt -> RETURN expression .

    DEF             reduce using rule 32 (return_stmt -> RETURN expression .)
    PASS            reduce using rule 32 (return_stmt -> RETURN expression .)
    RETURN          reduce using rule 32 (return_stmt -> RETURN expression .)
    IDENTIFIER      reduce using rule 32 (return_stmt -> RETURN expression .)
    IF              reduce using rule 32 (return_stmt -> RETURN expression .)
    FOR             reduce using rule 32 (return_stmt -> RETURN expression .)
    $end            reduce using rule 32 (return_stmt -> RETURN expression .)
    TAB             reduce using rule 32 (return_stmt -> RETURN expression .)
    ELIF            reduce using rule 32 (return_stmt -> RETURN expression .)
    ELSE            reduce using rule 32 (return_stmt -> RETURN expression .)


state 23

    (28) expression -> arithmetic_expr .
    (30) arithmetic_expr -> arithmetic_expr . arithmetic_op arithmetic_expr
    (42) arithmetic_op -> . PLUS
    (43) arithmetic_op -> . MINUS
    (44) arithmetic_op -> . MODULUS
    (45) arithmetic_op -> . DIVIDE
    (46) arithmetic_op -> . MULTIPLY
    (47) arithmetic_op -> . GR
    (48) arithmetic_op -> . LE
    (49) arithmetic_op -> . EQ
    (50) arithmetic_op -> . GREQ
    (51) arithmetic_op -> . LEEQ

    DEF             reduce using rule 28 (expression -> arithmetic_expr .)
    PASS            reduce using rule 28 (expression -> arithmetic_expr .)
    RETURN          reduce using rule 28 (expression -> arithmetic_expr .)
    IDENTIFIER      reduce using rule 28 (expression -> arithmetic_expr .)
    IF              reduce using rule 28 (expression -> arithmetic_expr .)
    FOR             reduce using rule 28 (expression -> arithmetic_expr .)
    $end            reduce using rule 28 (expression -> arithmetic_expr .)
    TAB             reduce using rule 28 (expression -> arithmetic_expr .)
    ELIF            reduce using rule 28 (expression -> arithmetic_expr .)
    ELSE            reduce using rule 28 (expression -> arithmetic_expr .)
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    MODULUS         shift and go to state 46
    DIVIDE          shift and go to state 47
    MULTIPLY        shift and go to state 48
    GR              shift and go to state 49
    LE              shift and go to state 50
    EQ              shift and go to state 51
    GREQ            shift and go to state 52
    LEEQ            shift and go to state 53

    arithmetic_op                  shift and go to state 43

state 24

    (29) expression -> func_call_stmt .

    DEF             reduce using rule 29 (expression -> func_call_stmt .)
    PASS            reduce using rule 29 (expression -> func_call_stmt .)
    RETURN          reduce using rule 29 (expression -> func_call_stmt .)
    IDENTIFIER      reduce using rule 29 (expression -> func_call_stmt .)
    IF              reduce using rule 29 (expression -> func_call_stmt .)
    FOR             reduce using rule 29 (expression -> func_call_stmt .)
    $end            reduce using rule 29 (expression -> func_call_stmt .)
    TAB             reduce using rule 29 (expression -> func_call_stmt .)
    ELIF            reduce using rule 29 (expression -> func_call_stmt .)
    ELSE            reduce using rule 29 (expression -> func_call_stmt .)


state 25

    (31) arithmetic_expr -> atom .

    PLUS            reduce using rule 31 (arithmetic_expr -> atom .)
    MINUS           reduce using rule 31 (arithmetic_expr -> atom .)
    MODULUS         reduce using rule 31 (arithmetic_expr -> atom .)
    DIVIDE          reduce using rule 31 (arithmetic_expr -> atom .)
    MULTIPLY        reduce using rule 31 (arithmetic_expr -> atom .)
    GR              reduce using rule 31 (arithmetic_expr -> atom .)
    LE              reduce using rule 31 (arithmetic_expr -> atom .)
    EQ              reduce using rule 31 (arithmetic_expr -> atom .)
    GREQ            reduce using rule 31 (arithmetic_expr -> atom .)
    LEEQ            reduce using rule 31 (arithmetic_expr -> atom .)
    DEF             reduce using rule 31 (arithmetic_expr -> atom .)
    PASS            reduce using rule 31 (arithmetic_expr -> atom .)
    RETURN          reduce using rule 31 (arithmetic_expr -> atom .)
    IDENTIFIER      reduce using rule 31 (arithmetic_expr -> atom .)
    IF              reduce using rule 31 (arithmetic_expr -> atom .)
    FOR             reduce using rule 31 (arithmetic_expr -> atom .)
    $end            reduce using rule 31 (arithmetic_expr -> atom .)
    TAB             reduce using rule 31 (arithmetic_expr -> atom .)
    ELIF            reduce using rule 31 (arithmetic_expr -> atom .)
    ELSE            reduce using rule 31 (arithmetic_expr -> atom .)
    RPAREN          reduce using rule 31 (arithmetic_expr -> atom .)


state 26

    (26) func_call_stmt -> IDENTIFIER . LPAREN parameters RPAREN
    (33) atom -> IDENTIFIER .

    LPAREN          shift and go to state 21
    PLUS            reduce using rule 33 (atom -> IDENTIFIER .)
    MINUS           reduce using rule 33 (atom -> IDENTIFIER .)
    MODULUS         reduce using rule 33 (atom -> IDENTIFIER .)
    DIVIDE          reduce using rule 33 (atom -> IDENTIFIER .)
    MULTIPLY        reduce using rule 33 (atom -> IDENTIFIER .)
    GR              reduce using rule 33 (atom -> IDENTIFIER .)
    LE              reduce using rule 33 (atom -> IDENTIFIER .)
    EQ              reduce using rule 33 (atom -> IDENTIFIER .)
    GREQ            reduce using rule 33 (atom -> IDENTIFIER .)
    LEEQ            reduce using rule 33 (atom -> IDENTIFIER .)
    DEF             reduce using rule 33 (atom -> IDENTIFIER .)
    PASS            reduce using rule 33 (atom -> IDENTIFIER .)
    RETURN          reduce using rule 33 (atom -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 33 (atom -> IDENTIFIER .)
    IF              reduce using rule 33 (atom -> IDENTIFIER .)
    FOR             reduce using rule 33 (atom -> IDENTIFIER .)
    $end            reduce using rule 33 (atom -> IDENTIFIER .)
    TAB             reduce using rule 33 (atom -> IDENTIFIER .)
    ELIF            reduce using rule 33 (atom -> IDENTIFIER .)
    ELSE            reduce using rule 33 (atom -> IDENTIFIER .)


state 27

    (34) atom -> literal .

    PLUS            reduce using rule 34 (atom -> literal .)
    MINUS           reduce using rule 34 (atom -> literal .)
    MODULUS         reduce using rule 34 (atom -> literal .)
    DIVIDE          reduce using rule 34 (atom -> literal .)
    MULTIPLY        reduce using rule 34 (atom -> literal .)
    GR              reduce using rule 34 (atom -> literal .)
    LE              reduce using rule 34 (atom -> literal .)
    EQ              reduce using rule 34 (atom -> literal .)
    GREQ            reduce using rule 34 (atom -> literal .)
    LEEQ            reduce using rule 34 (atom -> literal .)
    DEF             reduce using rule 34 (atom -> literal .)
    PASS            reduce using rule 34 (atom -> literal .)
    RETURN          reduce using rule 34 (atom -> literal .)
    IDENTIFIER      reduce using rule 34 (atom -> literal .)
    IF              reduce using rule 34 (atom -> literal .)
    FOR             reduce using rule 34 (atom -> literal .)
    $end            reduce using rule 34 (atom -> literal .)
    TAB             reduce using rule 34 (atom -> literal .)
    ELIF            reduce using rule 34 (atom -> literal .)
    ELSE            reduce using rule 34 (atom -> literal .)
    COMMA           reduce using rule 34 (atom -> literal .)
    RPAREN          reduce using rule 34 (atom -> literal .)
    RSQUARE         reduce using rule 34 (atom -> literal .)


state 28

    (35) literal -> NUMBER .

    PLUS            reduce using rule 35 (literal -> NUMBER .)
    MINUS           reduce using rule 35 (literal -> NUMBER .)
    MODULUS         reduce using rule 35 (literal -> NUMBER .)
    DIVIDE          reduce using rule 35 (literal -> NUMBER .)
    MULTIPLY        reduce using rule 35 (literal -> NUMBER .)
    GR              reduce using rule 35 (literal -> NUMBER .)
    LE              reduce using rule 35 (literal -> NUMBER .)
    EQ              reduce using rule 35 (literal -> NUMBER .)
    GREQ            reduce using rule 35 (literal -> NUMBER .)
    LEEQ            reduce using rule 35 (literal -> NUMBER .)
    DEF             reduce using rule 35 (literal -> NUMBER .)
    PASS            reduce using rule 35 (literal -> NUMBER .)
    RETURN          reduce using rule 35 (literal -> NUMBER .)
    IDENTIFIER      reduce using rule 35 (literal -> NUMBER .)
    IF              reduce using rule 35 (literal -> NUMBER .)
    FOR             reduce using rule 35 (literal -> NUMBER .)
    $end            reduce using rule 35 (literal -> NUMBER .)
    TAB             reduce using rule 35 (literal -> NUMBER .)
    ELIF            reduce using rule 35 (literal -> NUMBER .)
    ELSE            reduce using rule 35 (literal -> NUMBER .)
    COMMA           reduce using rule 35 (literal -> NUMBER .)
    RPAREN          reduce using rule 35 (literal -> NUMBER .)
    RSQUARE         reduce using rule 35 (literal -> NUMBER .)


state 29

    (36) literal -> NONE .

    PLUS            reduce using rule 36 (literal -> NONE .)
    MINUS           reduce using rule 36 (literal -> NONE .)
    MODULUS         reduce using rule 36 (literal -> NONE .)
    DIVIDE          reduce using rule 36 (literal -> NONE .)
    MULTIPLY        reduce using rule 36 (literal -> NONE .)
    GR              reduce using rule 36 (literal -> NONE .)
    LE              reduce using rule 36 (literal -> NONE .)
    EQ              reduce using rule 36 (literal -> NONE .)
    GREQ            reduce using rule 36 (literal -> NONE .)
    LEEQ            reduce using rule 36 (literal -> NONE .)
    DEF             reduce using rule 36 (literal -> NONE .)
    PASS            reduce using rule 36 (literal -> NONE .)
    RETURN          reduce using rule 36 (literal -> NONE .)
    IDENTIFIER      reduce using rule 36 (literal -> NONE .)
    IF              reduce using rule 36 (literal -> NONE .)
    FOR             reduce using rule 36 (literal -> NONE .)
    $end            reduce using rule 36 (literal -> NONE .)
    TAB             reduce using rule 36 (literal -> NONE .)
    ELIF            reduce using rule 36 (literal -> NONE .)
    ELSE            reduce using rule 36 (literal -> NONE .)
    COMMA           reduce using rule 36 (literal -> NONE .)
    RPAREN          reduce using rule 36 (literal -> NONE .)
    RSQUARE         reduce using rule 36 (literal -> NONE .)


state 30

    (37) literal -> TRUE .

    PLUS            reduce using rule 37 (literal -> TRUE .)
    MINUS           reduce using rule 37 (literal -> TRUE .)
    MODULUS         reduce using rule 37 (literal -> TRUE .)
    DIVIDE          reduce using rule 37 (literal -> TRUE .)
    MULTIPLY        reduce using rule 37 (literal -> TRUE .)
    GR              reduce using rule 37 (literal -> TRUE .)
    LE              reduce using rule 37 (literal -> TRUE .)
    EQ              reduce using rule 37 (literal -> TRUE .)
    GREQ            reduce using rule 37 (literal -> TRUE .)
    LEEQ            reduce using rule 37 (literal -> TRUE .)
    DEF             reduce using rule 37 (literal -> TRUE .)
    PASS            reduce using rule 37 (literal -> TRUE .)
    RETURN          reduce using rule 37 (literal -> TRUE .)
    IDENTIFIER      reduce using rule 37 (literal -> TRUE .)
    IF              reduce using rule 37 (literal -> TRUE .)
    FOR             reduce using rule 37 (literal -> TRUE .)
    $end            reduce using rule 37 (literal -> TRUE .)
    TAB             reduce using rule 37 (literal -> TRUE .)
    ELIF            reduce using rule 37 (literal -> TRUE .)
    ELSE            reduce using rule 37 (literal -> TRUE .)
    COMMA           reduce using rule 37 (literal -> TRUE .)
    RPAREN          reduce using rule 37 (literal -> TRUE .)
    RSQUARE         reduce using rule 37 (literal -> TRUE .)


state 31

    (38) literal -> FALSE .

    PLUS            reduce using rule 38 (literal -> FALSE .)
    MINUS           reduce using rule 38 (literal -> FALSE .)
    MODULUS         reduce using rule 38 (literal -> FALSE .)
    DIVIDE          reduce using rule 38 (literal -> FALSE .)
    MULTIPLY        reduce using rule 38 (literal -> FALSE .)
    GR              reduce using rule 38 (literal -> FALSE .)
    LE              reduce using rule 38 (literal -> FALSE .)
    EQ              reduce using rule 38 (literal -> FALSE .)
    GREQ            reduce using rule 38 (literal -> FALSE .)
    LEEQ            reduce using rule 38 (literal -> FALSE .)
    DEF             reduce using rule 38 (literal -> FALSE .)
    PASS            reduce using rule 38 (literal -> FALSE .)
    RETURN          reduce using rule 38 (literal -> FALSE .)
    IDENTIFIER      reduce using rule 38 (literal -> FALSE .)
    IF              reduce using rule 38 (literal -> FALSE .)
    FOR             reduce using rule 38 (literal -> FALSE .)
    $end            reduce using rule 38 (literal -> FALSE .)
    TAB             reduce using rule 38 (literal -> FALSE .)
    ELIF            reduce using rule 38 (literal -> FALSE .)
    ELSE            reduce using rule 38 (literal -> FALSE .)
    COMMA           reduce using rule 38 (literal -> FALSE .)
    RPAREN          reduce using rule 38 (literal -> FALSE .)
    RSQUARE         reduce using rule 38 (literal -> FALSE .)


state 32

    (39) literal -> STRING .

    PLUS            reduce using rule 39 (literal -> STRING .)
    MINUS           reduce using rule 39 (literal -> STRING .)
    MODULUS         reduce using rule 39 (literal -> STRING .)
    DIVIDE          reduce using rule 39 (literal -> STRING .)
    MULTIPLY        reduce using rule 39 (literal -> STRING .)
    GR              reduce using rule 39 (literal -> STRING .)
    LE              reduce using rule 39 (literal -> STRING .)
    EQ              reduce using rule 39 (literal -> STRING .)
    GREQ            reduce using rule 39 (literal -> STRING .)
    LEEQ            reduce using rule 39 (literal -> STRING .)
    DEF             reduce using rule 39 (literal -> STRING .)
    PASS            reduce using rule 39 (literal -> STRING .)
    RETURN          reduce using rule 39 (literal -> STRING .)
    IDENTIFIER      reduce using rule 39 (literal -> STRING .)
    IF              reduce using rule 39 (literal -> STRING .)
    FOR             reduce using rule 39 (literal -> STRING .)
    $end            reduce using rule 39 (literal -> STRING .)
    TAB             reduce using rule 39 (literal -> STRING .)
    ELIF            reduce using rule 39 (literal -> STRING .)
    ELSE            reduce using rule 39 (literal -> STRING .)
    COMMA           reduce using rule 39 (literal -> STRING .)
    RPAREN          reduce using rule 39 (literal -> STRING .)
    RSQUARE         reduce using rule 39 (literal -> STRING .)


state 33

    (40) literal -> list .

    PLUS            reduce using rule 40 (literal -> list .)
    MINUS           reduce using rule 40 (literal -> list .)
    MODULUS         reduce using rule 40 (literal -> list .)
    DIVIDE          reduce using rule 40 (literal -> list .)
    MULTIPLY        reduce using rule 40 (literal -> list .)
    GR              reduce using rule 40 (literal -> list .)
    LE              reduce using rule 40 (literal -> list .)
    EQ              reduce using rule 40 (literal -> list .)
    GREQ            reduce using rule 40 (literal -> list .)
    LEEQ            reduce using rule 40 (literal -> list .)
    DEF             reduce using rule 40 (literal -> list .)
    PASS            reduce using rule 40 (literal -> list .)
    RETURN          reduce using rule 40 (literal -> list .)
    IDENTIFIER      reduce using rule 40 (literal -> list .)
    IF              reduce using rule 40 (literal -> list .)
    FOR             reduce using rule 40 (literal -> list .)
    $end            reduce using rule 40 (literal -> list .)
    TAB             reduce using rule 40 (literal -> list .)
    ELIF            reduce using rule 40 (literal -> list .)
    ELSE            reduce using rule 40 (literal -> list .)
    COMMA           reduce using rule 40 (literal -> list .)
    RPAREN          reduce using rule 40 (literal -> list .)
    RSQUARE         reduce using rule 40 (literal -> list .)


state 34

    (41) list -> LSQUARE . parameters RSQUARE
    (23) parameters -> . atom
    (24) parameters -> . atom COMMA parameters
    (25) parameters -> . empty
    (33) atom -> . IDENTIFIER
    (34) atom -> . literal
    (52) empty -> .
    (35) literal -> . NUMBER
    (36) literal -> . NONE
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . STRING
    (40) literal -> . list
    (41) list -> . LSQUARE parameters RSQUARE

    IDENTIFIER      shift and go to state 39
    RSQUARE         reduce using rule 52 (empty -> .)
    NUMBER          shift and go to state 28
    NONE            shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    STRING          shift and go to state 32
    LSQUARE         shift and go to state 34

    parameters                     shift and go to state 54
    atom                           shift and go to state 41
    empty                          shift and go to state 42
    literal                        shift and go to state 27
    list                           shift and go to state 33

state 35

    (16) if_stmt -> IF LPAREN . arithmetic_expr RPAREN COLON statement_suite
    (17) if_stmt -> IF LPAREN . arithmetic_expr RPAREN COLON statement_suite elif_stmt
    (30) arithmetic_expr -> . arithmetic_expr arithmetic_op arithmetic_expr
    (31) arithmetic_expr -> . atom
    (33) atom -> . IDENTIFIER
    (34) atom -> . literal
    (35) literal -> . NUMBER
    (36) literal -> . NONE
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . STRING
    (40) literal -> . list
    (41) list -> . LSQUARE parameters RSQUARE

    IDENTIFIER      shift and go to state 39
    NUMBER          shift and go to state 28
    NONE            shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    STRING          shift and go to state 32
    LSQUARE         shift and go to state 34

    arithmetic_expr                shift and go to state 55
    atom                           shift and go to state 25
    literal                        shift and go to state 27
    list                           shift and go to state 33

state 36

    (15) for_loop -> FOR IDENTIFIER . IN IDENTIFIER COLON statement_suite

    IN              shift and go to state 56


state 37

    (21) funcdef -> DEF IDENTIFIER LPAREN . parameters RPAREN COLON statement_suite
    (22) funcdef -> DEF IDENTIFIER LPAREN . RPAREN COLON statement_suite
    (23) parameters -> . atom
    (24) parameters -> . atom COMMA parameters
    (25) parameters -> . empty
    (33) atom -> . IDENTIFIER
    (34) atom -> . literal
    (52) empty -> .
    (35) literal -> . NUMBER
    (36) literal -> . NONE
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . STRING
    (40) literal -> . list
    (41) list -> . LSQUARE parameters RSQUARE

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 58
    IDENTIFIER      shift and go to state 39
    NUMBER          shift and go to state 28
    NONE            shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    STRING          shift and go to state 32
    LSQUARE         shift and go to state 34

  ! RPAREN          [ reduce using rule 52 (empty -> .) ]

    parameters                     shift and go to state 57
    atom                           shift and go to state 41
    empty                          shift and go to state 42
    literal                        shift and go to state 27
    list                           shift and go to state 33

state 38

    (27) assignment_stmt -> IDENTIFIER EQUALS expression .

    DEF             reduce using rule 27 (assignment_stmt -> IDENTIFIER EQUALS expression .)
    PASS            reduce using rule 27 (assignment_stmt -> IDENTIFIER EQUALS expression .)
    RETURN          reduce using rule 27 (assignment_stmt -> IDENTIFIER EQUALS expression .)
    IDENTIFIER      reduce using rule 27 (assignment_stmt -> IDENTIFIER EQUALS expression .)
    IF              reduce using rule 27 (assignment_stmt -> IDENTIFIER EQUALS expression .)
    FOR             reduce using rule 27 (assignment_stmt -> IDENTIFIER EQUALS expression .)
    $end            reduce using rule 27 (assignment_stmt -> IDENTIFIER EQUALS expression .)
    TAB             reduce using rule 27 (assignment_stmt -> IDENTIFIER EQUALS expression .)
    ELIF            reduce using rule 27 (assignment_stmt -> IDENTIFIER EQUALS expression .)
    ELSE            reduce using rule 27 (assignment_stmt -> IDENTIFIER EQUALS expression .)


state 39

    (33) atom -> IDENTIFIER .

    COMMA           reduce using rule 33 (atom -> IDENTIFIER .)
    RPAREN          reduce using rule 33 (atom -> IDENTIFIER .)
    RSQUARE         reduce using rule 33 (atom -> IDENTIFIER .)
    PLUS            reduce using rule 33 (atom -> IDENTIFIER .)
    MINUS           reduce using rule 33 (atom -> IDENTIFIER .)
    MODULUS         reduce using rule 33 (atom -> IDENTIFIER .)
    DIVIDE          reduce using rule 33 (atom -> IDENTIFIER .)
    MULTIPLY        reduce using rule 33 (atom -> IDENTIFIER .)
    GR              reduce using rule 33 (atom -> IDENTIFIER .)
    LE              reduce using rule 33 (atom -> IDENTIFIER .)
    EQ              reduce using rule 33 (atom -> IDENTIFIER .)
    GREQ            reduce using rule 33 (atom -> IDENTIFIER .)
    LEEQ            reduce using rule 33 (atom -> IDENTIFIER .)
    DEF             reduce using rule 33 (atom -> IDENTIFIER .)
    PASS            reduce using rule 33 (atom -> IDENTIFIER .)
    RETURN          reduce using rule 33 (atom -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 33 (atom -> IDENTIFIER .)
    IF              reduce using rule 33 (atom -> IDENTIFIER .)
    FOR             reduce using rule 33 (atom -> IDENTIFIER .)
    $end            reduce using rule 33 (atom -> IDENTIFIER .)
    TAB             reduce using rule 33 (atom -> IDENTIFIER .)
    ELIF            reduce using rule 33 (atom -> IDENTIFIER .)
    ELSE            reduce using rule 33 (atom -> IDENTIFIER .)


state 40

    (26) func_call_stmt -> IDENTIFIER LPAREN parameters . RPAREN

    RPAREN          shift and go to state 59


state 41

    (23) parameters -> atom .
    (24) parameters -> atom . COMMA parameters

    RPAREN          reduce using rule 23 (parameters -> atom .)
    RSQUARE         reduce using rule 23 (parameters -> atom .)
    COMMA           shift and go to state 60


state 42

    (25) parameters -> empty .

    RPAREN          reduce using rule 25 (parameters -> empty .)
    RSQUARE         reduce using rule 25 (parameters -> empty .)


state 43

    (30) arithmetic_expr -> arithmetic_expr arithmetic_op . arithmetic_expr
    (30) arithmetic_expr -> . arithmetic_expr arithmetic_op arithmetic_expr
    (31) arithmetic_expr -> . atom
    (33) atom -> . IDENTIFIER
    (34) atom -> . literal
    (35) literal -> . NUMBER
    (36) literal -> . NONE
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . STRING
    (40) literal -> . list
    (41) list -> . LSQUARE parameters RSQUARE

    IDENTIFIER      shift and go to state 39
    NUMBER          shift and go to state 28
    NONE            shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    STRING          shift and go to state 32
    LSQUARE         shift and go to state 34

    arithmetic_expr                shift and go to state 61
    atom                           shift and go to state 25
    literal                        shift and go to state 27
    list                           shift and go to state 33

state 44

    (42) arithmetic_op -> PLUS .

    IDENTIFIER      reduce using rule 42 (arithmetic_op -> PLUS .)
    NUMBER          reduce using rule 42 (arithmetic_op -> PLUS .)
    NONE            reduce using rule 42 (arithmetic_op -> PLUS .)
    TRUE            reduce using rule 42 (arithmetic_op -> PLUS .)
    FALSE           reduce using rule 42 (arithmetic_op -> PLUS .)
    STRING          reduce using rule 42 (arithmetic_op -> PLUS .)
    LSQUARE         reduce using rule 42 (arithmetic_op -> PLUS .)


state 45

    (43) arithmetic_op -> MINUS .

    IDENTIFIER      reduce using rule 43 (arithmetic_op -> MINUS .)
    NUMBER          reduce using rule 43 (arithmetic_op -> MINUS .)
    NONE            reduce using rule 43 (arithmetic_op -> MINUS .)
    TRUE            reduce using rule 43 (arithmetic_op -> MINUS .)
    FALSE           reduce using rule 43 (arithmetic_op -> MINUS .)
    STRING          reduce using rule 43 (arithmetic_op -> MINUS .)
    LSQUARE         reduce using rule 43 (arithmetic_op -> MINUS .)


state 46

    (44) arithmetic_op -> MODULUS .

    IDENTIFIER      reduce using rule 44 (arithmetic_op -> MODULUS .)
    NUMBER          reduce using rule 44 (arithmetic_op -> MODULUS .)
    NONE            reduce using rule 44 (arithmetic_op -> MODULUS .)
    TRUE            reduce using rule 44 (arithmetic_op -> MODULUS .)
    FALSE           reduce using rule 44 (arithmetic_op -> MODULUS .)
    STRING          reduce using rule 44 (arithmetic_op -> MODULUS .)
    LSQUARE         reduce using rule 44 (arithmetic_op -> MODULUS .)


state 47

    (45) arithmetic_op -> DIVIDE .

    IDENTIFIER      reduce using rule 45 (arithmetic_op -> DIVIDE .)
    NUMBER          reduce using rule 45 (arithmetic_op -> DIVIDE .)
    NONE            reduce using rule 45 (arithmetic_op -> DIVIDE .)
    TRUE            reduce using rule 45 (arithmetic_op -> DIVIDE .)
    FALSE           reduce using rule 45 (arithmetic_op -> DIVIDE .)
    STRING          reduce using rule 45 (arithmetic_op -> DIVIDE .)
    LSQUARE         reduce using rule 45 (arithmetic_op -> DIVIDE .)


state 48

    (46) arithmetic_op -> MULTIPLY .

    IDENTIFIER      reduce using rule 46 (arithmetic_op -> MULTIPLY .)
    NUMBER          reduce using rule 46 (arithmetic_op -> MULTIPLY .)
    NONE            reduce using rule 46 (arithmetic_op -> MULTIPLY .)
    TRUE            reduce using rule 46 (arithmetic_op -> MULTIPLY .)
    FALSE           reduce using rule 46 (arithmetic_op -> MULTIPLY .)
    STRING          reduce using rule 46 (arithmetic_op -> MULTIPLY .)
    LSQUARE         reduce using rule 46 (arithmetic_op -> MULTIPLY .)


state 49

    (47) arithmetic_op -> GR .

    IDENTIFIER      reduce using rule 47 (arithmetic_op -> GR .)
    NUMBER          reduce using rule 47 (arithmetic_op -> GR .)
    NONE            reduce using rule 47 (arithmetic_op -> GR .)
    TRUE            reduce using rule 47 (arithmetic_op -> GR .)
    FALSE           reduce using rule 47 (arithmetic_op -> GR .)
    STRING          reduce using rule 47 (arithmetic_op -> GR .)
    LSQUARE         reduce using rule 47 (arithmetic_op -> GR .)


state 50

    (48) arithmetic_op -> LE .

    IDENTIFIER      reduce using rule 48 (arithmetic_op -> LE .)
    NUMBER          reduce using rule 48 (arithmetic_op -> LE .)
    NONE            reduce using rule 48 (arithmetic_op -> LE .)
    TRUE            reduce using rule 48 (arithmetic_op -> LE .)
    FALSE           reduce using rule 48 (arithmetic_op -> LE .)
    STRING          reduce using rule 48 (arithmetic_op -> LE .)
    LSQUARE         reduce using rule 48 (arithmetic_op -> LE .)


state 51

    (49) arithmetic_op -> EQ .

    IDENTIFIER      reduce using rule 49 (arithmetic_op -> EQ .)
    NUMBER          reduce using rule 49 (arithmetic_op -> EQ .)
    NONE            reduce using rule 49 (arithmetic_op -> EQ .)
    TRUE            reduce using rule 49 (arithmetic_op -> EQ .)
    FALSE           reduce using rule 49 (arithmetic_op -> EQ .)
    STRING          reduce using rule 49 (arithmetic_op -> EQ .)
    LSQUARE         reduce using rule 49 (arithmetic_op -> EQ .)


state 52

    (50) arithmetic_op -> GREQ .

    IDENTIFIER      reduce using rule 50 (arithmetic_op -> GREQ .)
    NUMBER          reduce using rule 50 (arithmetic_op -> GREQ .)
    NONE            reduce using rule 50 (arithmetic_op -> GREQ .)
    TRUE            reduce using rule 50 (arithmetic_op -> GREQ .)
    FALSE           reduce using rule 50 (arithmetic_op -> GREQ .)
    STRING          reduce using rule 50 (arithmetic_op -> GREQ .)
    LSQUARE         reduce using rule 50 (arithmetic_op -> GREQ .)


state 53

    (51) arithmetic_op -> LEEQ .

    IDENTIFIER      reduce using rule 51 (arithmetic_op -> LEEQ .)
    NUMBER          reduce using rule 51 (arithmetic_op -> LEEQ .)
    NONE            reduce using rule 51 (arithmetic_op -> LEEQ .)
    TRUE            reduce using rule 51 (arithmetic_op -> LEEQ .)
    FALSE           reduce using rule 51 (arithmetic_op -> LEEQ .)
    STRING          reduce using rule 51 (arithmetic_op -> LEEQ .)
    LSQUARE         reduce using rule 51 (arithmetic_op -> LEEQ .)


state 54

    (41) list -> LSQUARE parameters . RSQUARE

    RSQUARE         shift and go to state 62


state 55

    (16) if_stmt -> IF LPAREN arithmetic_expr . RPAREN COLON statement_suite
    (17) if_stmt -> IF LPAREN arithmetic_expr . RPAREN COLON statement_suite elif_stmt
    (30) arithmetic_expr -> arithmetic_expr . arithmetic_op arithmetic_expr
    (42) arithmetic_op -> . PLUS
    (43) arithmetic_op -> . MINUS
    (44) arithmetic_op -> . MODULUS
    (45) arithmetic_op -> . DIVIDE
    (46) arithmetic_op -> . MULTIPLY
    (47) arithmetic_op -> . GR
    (48) arithmetic_op -> . LE
    (49) arithmetic_op -> . EQ
    (50) arithmetic_op -> . GREQ
    (51) arithmetic_op -> . LEEQ

    RPAREN          shift and go to state 63
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    MODULUS         shift and go to state 46
    DIVIDE          shift and go to state 47
    MULTIPLY        shift and go to state 48
    GR              shift and go to state 49
    LE              shift and go to state 50
    EQ              shift and go to state 51
    GREQ            shift and go to state 52
    LEEQ            shift and go to state 53

    arithmetic_op                  shift and go to state 43

state 56

    (15) for_loop -> FOR IDENTIFIER IN . IDENTIFIER COLON statement_suite

    IDENTIFIER      shift and go to state 64


state 57

    (21) funcdef -> DEF IDENTIFIER LPAREN parameters . RPAREN COLON statement_suite

    RPAREN          shift and go to state 65


state 58

    (22) funcdef -> DEF IDENTIFIER LPAREN RPAREN . COLON statement_suite

    COLON           shift and go to state 66


state 59

    (26) func_call_stmt -> IDENTIFIER LPAREN parameters RPAREN .

    DEF             reduce using rule 26 (func_call_stmt -> IDENTIFIER LPAREN parameters RPAREN .)
    PASS            reduce using rule 26 (func_call_stmt -> IDENTIFIER LPAREN parameters RPAREN .)
    RETURN          reduce using rule 26 (func_call_stmt -> IDENTIFIER LPAREN parameters RPAREN .)
    IDENTIFIER      reduce using rule 26 (func_call_stmt -> IDENTIFIER LPAREN parameters RPAREN .)
    IF              reduce using rule 26 (func_call_stmt -> IDENTIFIER LPAREN parameters RPAREN .)
    FOR             reduce using rule 26 (func_call_stmt -> IDENTIFIER LPAREN parameters RPAREN .)
    $end            reduce using rule 26 (func_call_stmt -> IDENTIFIER LPAREN parameters RPAREN .)
    TAB             reduce using rule 26 (func_call_stmt -> IDENTIFIER LPAREN parameters RPAREN .)
    ELIF            reduce using rule 26 (func_call_stmt -> IDENTIFIER LPAREN parameters RPAREN .)
    ELSE            reduce using rule 26 (func_call_stmt -> IDENTIFIER LPAREN parameters RPAREN .)


state 60

    (24) parameters -> atom COMMA . parameters
    (23) parameters -> . atom
    (24) parameters -> . atom COMMA parameters
    (25) parameters -> . empty
    (33) atom -> . IDENTIFIER
    (34) atom -> . literal
    (52) empty -> .
    (35) literal -> . NUMBER
    (36) literal -> . NONE
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . STRING
    (40) literal -> . list
    (41) list -> . LSQUARE parameters RSQUARE

    IDENTIFIER      shift and go to state 39
    RPAREN          reduce using rule 52 (empty -> .)
    RSQUARE         reduce using rule 52 (empty -> .)
    NUMBER          shift and go to state 28
    NONE            shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    STRING          shift and go to state 32
    LSQUARE         shift and go to state 34

    atom                           shift and go to state 41
    parameters                     shift and go to state 67
    empty                          shift and go to state 42
    literal                        shift and go to state 27
    list                           shift and go to state 33

state 61

    (30) arithmetic_expr -> arithmetic_expr arithmetic_op arithmetic_expr .
    (30) arithmetic_expr -> arithmetic_expr . arithmetic_op arithmetic_expr
    (42) arithmetic_op -> . PLUS
    (43) arithmetic_op -> . MINUS
    (44) arithmetic_op -> . MODULUS
    (45) arithmetic_op -> . DIVIDE
    (46) arithmetic_op -> . MULTIPLY
    (47) arithmetic_op -> . GR
    (48) arithmetic_op -> . LE
    (49) arithmetic_op -> . EQ
    (50) arithmetic_op -> . GREQ
    (51) arithmetic_op -> . LEEQ

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for GR resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for GREQ resolved as shift
  ! shift/reduce conflict for LEEQ resolved as shift
    DEF             reduce using rule 30 (arithmetic_expr -> arithmetic_expr arithmetic_op arithmetic_expr .)
    PASS            reduce using rule 30 (arithmetic_expr -> arithmetic_expr arithmetic_op arithmetic_expr .)
    RETURN          reduce using rule 30 (arithmetic_expr -> arithmetic_expr arithmetic_op arithmetic_expr .)
    IDENTIFIER      reduce using rule 30 (arithmetic_expr -> arithmetic_expr arithmetic_op arithmetic_expr .)
    IF              reduce using rule 30 (arithmetic_expr -> arithmetic_expr arithmetic_op arithmetic_expr .)
    FOR             reduce using rule 30 (arithmetic_expr -> arithmetic_expr arithmetic_op arithmetic_expr .)
    $end            reduce using rule 30 (arithmetic_expr -> arithmetic_expr arithmetic_op arithmetic_expr .)
    TAB             reduce using rule 30 (arithmetic_expr -> arithmetic_expr arithmetic_op arithmetic_expr .)
    ELIF            reduce using rule 30 (arithmetic_expr -> arithmetic_expr arithmetic_op arithmetic_expr .)
    ELSE            reduce using rule 30 (arithmetic_expr -> arithmetic_expr arithmetic_op arithmetic_expr .)
    RPAREN          reduce using rule 30 (arithmetic_expr -> arithmetic_expr arithmetic_op arithmetic_expr .)
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    MODULUS         shift and go to state 46
    DIVIDE          shift and go to state 47
    MULTIPLY        shift and go to state 48
    GR              shift and go to state 49
    LE              shift and go to state 50
    EQ              shift and go to state 51
    GREQ            shift and go to state 52
    LEEQ            shift and go to state 53

  ! PLUS            [ reduce using rule 30 (arithmetic_expr -> arithmetic_expr arithmetic_op arithmetic_expr .) ]
  ! MINUS           [ reduce using rule 30 (arithmetic_expr -> arithmetic_expr arithmetic_op arithmetic_expr .) ]
  ! MODULUS         [ reduce using rule 30 (arithmetic_expr -> arithmetic_expr arithmetic_op arithmetic_expr .) ]
  ! DIVIDE          [ reduce using rule 30 (arithmetic_expr -> arithmetic_expr arithmetic_op arithmetic_expr .) ]
  ! MULTIPLY        [ reduce using rule 30 (arithmetic_expr -> arithmetic_expr arithmetic_op arithmetic_expr .) ]
  ! GR              [ reduce using rule 30 (arithmetic_expr -> arithmetic_expr arithmetic_op arithmetic_expr .) ]
  ! LE              [ reduce using rule 30 (arithmetic_expr -> arithmetic_expr arithmetic_op arithmetic_expr .) ]
  ! EQ              [ reduce using rule 30 (arithmetic_expr -> arithmetic_expr arithmetic_op arithmetic_expr .) ]
  ! GREQ            [ reduce using rule 30 (arithmetic_expr -> arithmetic_expr arithmetic_op arithmetic_expr .) ]
  ! LEEQ            [ reduce using rule 30 (arithmetic_expr -> arithmetic_expr arithmetic_op arithmetic_expr .) ]

    arithmetic_op                  shift and go to state 43

state 62

    (41) list -> LSQUARE parameters RSQUARE .

    PLUS            reduce using rule 41 (list -> LSQUARE parameters RSQUARE .)
    MINUS           reduce using rule 41 (list -> LSQUARE parameters RSQUARE .)
    MODULUS         reduce using rule 41 (list -> LSQUARE parameters RSQUARE .)
    DIVIDE          reduce using rule 41 (list -> LSQUARE parameters RSQUARE .)
    MULTIPLY        reduce using rule 41 (list -> LSQUARE parameters RSQUARE .)
    GR              reduce using rule 41 (list -> LSQUARE parameters RSQUARE .)
    LE              reduce using rule 41 (list -> LSQUARE parameters RSQUARE .)
    EQ              reduce using rule 41 (list -> LSQUARE parameters RSQUARE .)
    GREQ            reduce using rule 41 (list -> LSQUARE parameters RSQUARE .)
    LEEQ            reduce using rule 41 (list -> LSQUARE parameters RSQUARE .)
    DEF             reduce using rule 41 (list -> LSQUARE parameters RSQUARE .)
    PASS            reduce using rule 41 (list -> LSQUARE parameters RSQUARE .)
    RETURN          reduce using rule 41 (list -> LSQUARE parameters RSQUARE .)
    IDENTIFIER      reduce using rule 41 (list -> LSQUARE parameters RSQUARE .)
    IF              reduce using rule 41 (list -> LSQUARE parameters RSQUARE .)
    FOR             reduce using rule 41 (list -> LSQUARE parameters RSQUARE .)
    $end            reduce using rule 41 (list -> LSQUARE parameters RSQUARE .)
    TAB             reduce using rule 41 (list -> LSQUARE parameters RSQUARE .)
    ELIF            reduce using rule 41 (list -> LSQUARE parameters RSQUARE .)
    ELSE            reduce using rule 41 (list -> LSQUARE parameters RSQUARE .)
    COMMA           reduce using rule 41 (list -> LSQUARE parameters RSQUARE .)
    RPAREN          reduce using rule 41 (list -> LSQUARE parameters RSQUARE .)
    RSQUARE         reduce using rule 41 (list -> LSQUARE parameters RSQUARE .)


state 63

    (16) if_stmt -> IF LPAREN arithmetic_expr RPAREN . COLON statement_suite
    (17) if_stmt -> IF LPAREN arithmetic_expr RPAREN . COLON statement_suite elif_stmt

    COLON           shift and go to state 68


state 64

    (15) for_loop -> FOR IDENTIFIER IN IDENTIFIER . COLON statement_suite

    COLON           shift and go to state 69


state 65

    (21) funcdef -> DEF IDENTIFIER LPAREN parameters RPAREN . COLON statement_suite

    COLON           shift and go to state 70


state 66

    (22) funcdef -> DEF IDENTIFIER LPAREN RPAREN COLON . statement_suite
    (6) statement_suite -> . TAB statement
    (7) statement_suite -> . TAB statement statement_suite

    TAB             shift and go to state 72

    statement_suite                shift and go to state 71

state 67

    (24) parameters -> atom COMMA parameters .

    RPAREN          reduce using rule 24 (parameters -> atom COMMA parameters .)
    RSQUARE         reduce using rule 24 (parameters -> atom COMMA parameters .)


state 68

    (16) if_stmt -> IF LPAREN arithmetic_expr RPAREN COLON . statement_suite
    (17) if_stmt -> IF LPAREN arithmetic_expr RPAREN COLON . statement_suite elif_stmt
    (6) statement_suite -> . TAB statement
    (7) statement_suite -> . TAB statement statement_suite

    TAB             shift and go to state 72

    statement_suite                shift and go to state 73

state 69

    (15) for_loop -> FOR IDENTIFIER IN IDENTIFIER COLON . statement_suite
    (6) statement_suite -> . TAB statement
    (7) statement_suite -> . TAB statement statement_suite

    TAB             shift and go to state 72

    statement_suite                shift and go to state 74

state 70

    (21) funcdef -> DEF IDENTIFIER LPAREN parameters RPAREN COLON . statement_suite
    (6) statement_suite -> . TAB statement
    (7) statement_suite -> . TAB statement statement_suite

    TAB             shift and go to state 72

    statement_suite                shift and go to state 75

state 71

    (22) funcdef -> DEF IDENTIFIER LPAREN RPAREN COLON statement_suite .

    DEF             reduce using rule 22 (funcdef -> DEF IDENTIFIER LPAREN RPAREN COLON statement_suite .)
    PASS            reduce using rule 22 (funcdef -> DEF IDENTIFIER LPAREN RPAREN COLON statement_suite .)
    RETURN          reduce using rule 22 (funcdef -> DEF IDENTIFIER LPAREN RPAREN COLON statement_suite .)
    IDENTIFIER      reduce using rule 22 (funcdef -> DEF IDENTIFIER LPAREN RPAREN COLON statement_suite .)
    IF              reduce using rule 22 (funcdef -> DEF IDENTIFIER LPAREN RPAREN COLON statement_suite .)
    FOR             reduce using rule 22 (funcdef -> DEF IDENTIFIER LPAREN RPAREN COLON statement_suite .)
    $end            reduce using rule 22 (funcdef -> DEF IDENTIFIER LPAREN RPAREN COLON statement_suite .)


state 72

    (6) statement_suite -> TAB . statement
    (7) statement_suite -> TAB . statement statement_suite
    (8) statement -> . return_stmt
    (9) statement -> . assignment_stmt
    (10) statement -> . func_call_stmt
    (11) statement -> . loop_stmt
    (12) statement -> . if_stmt
    (13) statement -> . PASS
    (32) return_stmt -> . RETURN expression
    (27) assignment_stmt -> . IDENTIFIER EQUALS expression
    (26) func_call_stmt -> . IDENTIFIER LPAREN parameters RPAREN
    (14) loop_stmt -> . for_loop
    (16) if_stmt -> . IF LPAREN arithmetic_expr RPAREN COLON statement_suite
    (17) if_stmt -> . IF LPAREN arithmetic_expr RPAREN COLON statement_suite elif_stmt
    (15) for_loop -> . FOR IDENTIFIER IN IDENTIFIER COLON statement_suite

    PASS            shift and go to state 12
    RETURN          shift and go to state 13
    IDENTIFIER      shift and go to state 6
    IF              shift and go to state 15
    FOR             shift and go to state 16

    statement                      shift and go to state 76
    return_stmt                    shift and go to state 7
    assignment_stmt                shift and go to state 8
    func_call_stmt                 shift and go to state 9
    loop_stmt                      shift and go to state 10
    if_stmt                        shift and go to state 11
    for_loop                       shift and go to state 14

state 73

    (16) if_stmt -> IF LPAREN arithmetic_expr RPAREN COLON statement_suite .
    (17) if_stmt -> IF LPAREN arithmetic_expr RPAREN COLON statement_suite . elif_stmt
    (18) elif_stmt -> . ELIF LPAREN arithmetic_expr RPAREN COLON statement_suite else_stmt
    (19) elif_stmt -> . else_stmt
    (20) else_stmt -> . ELSE COLON statement_suite

  ! shift/reduce conflict for ELIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
    DEF             reduce using rule 16 (if_stmt -> IF LPAREN arithmetic_expr RPAREN COLON statement_suite .)
    PASS            reduce using rule 16 (if_stmt -> IF LPAREN arithmetic_expr RPAREN COLON statement_suite .)
    RETURN          reduce using rule 16 (if_stmt -> IF LPAREN arithmetic_expr RPAREN COLON statement_suite .)
    IDENTIFIER      reduce using rule 16 (if_stmt -> IF LPAREN arithmetic_expr RPAREN COLON statement_suite .)
    IF              reduce using rule 16 (if_stmt -> IF LPAREN arithmetic_expr RPAREN COLON statement_suite .)
    FOR             reduce using rule 16 (if_stmt -> IF LPAREN arithmetic_expr RPAREN COLON statement_suite .)
    $end            reduce using rule 16 (if_stmt -> IF LPAREN arithmetic_expr RPAREN COLON statement_suite .)
    TAB             reduce using rule 16 (if_stmt -> IF LPAREN arithmetic_expr RPAREN COLON statement_suite .)
    ELIF            shift and go to state 78
    ELSE            shift and go to state 80

  ! ELIF            [ reduce using rule 16 (if_stmt -> IF LPAREN arithmetic_expr RPAREN COLON statement_suite .) ]
  ! ELSE            [ reduce using rule 16 (if_stmt -> IF LPAREN arithmetic_expr RPAREN COLON statement_suite .) ]

    elif_stmt                      shift and go to state 77
    else_stmt                      shift and go to state 79

state 74

    (15) for_loop -> FOR IDENTIFIER IN IDENTIFIER COLON statement_suite .

    DEF             reduce using rule 15 (for_loop -> FOR IDENTIFIER IN IDENTIFIER COLON statement_suite .)
    PASS            reduce using rule 15 (for_loop -> FOR IDENTIFIER IN IDENTIFIER COLON statement_suite .)
    RETURN          reduce using rule 15 (for_loop -> FOR IDENTIFIER IN IDENTIFIER COLON statement_suite .)
    IDENTIFIER      reduce using rule 15 (for_loop -> FOR IDENTIFIER IN IDENTIFIER COLON statement_suite .)
    IF              reduce using rule 15 (for_loop -> FOR IDENTIFIER IN IDENTIFIER COLON statement_suite .)
    FOR             reduce using rule 15 (for_loop -> FOR IDENTIFIER IN IDENTIFIER COLON statement_suite .)
    $end            reduce using rule 15 (for_loop -> FOR IDENTIFIER IN IDENTIFIER COLON statement_suite .)
    TAB             reduce using rule 15 (for_loop -> FOR IDENTIFIER IN IDENTIFIER COLON statement_suite .)
    ELIF            reduce using rule 15 (for_loop -> FOR IDENTIFIER IN IDENTIFIER COLON statement_suite .)
    ELSE            reduce using rule 15 (for_loop -> FOR IDENTIFIER IN IDENTIFIER COLON statement_suite .)


state 75

    (21) funcdef -> DEF IDENTIFIER LPAREN parameters RPAREN COLON statement_suite .

    DEF             reduce using rule 21 (funcdef -> DEF IDENTIFIER LPAREN parameters RPAREN COLON statement_suite .)
    PASS            reduce using rule 21 (funcdef -> DEF IDENTIFIER LPAREN parameters RPAREN COLON statement_suite .)
    RETURN          reduce using rule 21 (funcdef -> DEF IDENTIFIER LPAREN parameters RPAREN COLON statement_suite .)
    IDENTIFIER      reduce using rule 21 (funcdef -> DEF IDENTIFIER LPAREN parameters RPAREN COLON statement_suite .)
    IF              reduce using rule 21 (funcdef -> DEF IDENTIFIER LPAREN parameters RPAREN COLON statement_suite .)
    FOR             reduce using rule 21 (funcdef -> DEF IDENTIFIER LPAREN parameters RPAREN COLON statement_suite .)
    $end            reduce using rule 21 (funcdef -> DEF IDENTIFIER LPAREN parameters RPAREN COLON statement_suite .)


state 76

    (6) statement_suite -> TAB statement .
    (7) statement_suite -> TAB statement . statement_suite
    (6) statement_suite -> . TAB statement
    (7) statement_suite -> . TAB statement statement_suite

  ! shift/reduce conflict for TAB resolved as shift
    DEF             reduce using rule 6 (statement_suite -> TAB statement .)
    PASS            reduce using rule 6 (statement_suite -> TAB statement .)
    RETURN          reduce using rule 6 (statement_suite -> TAB statement .)
    IDENTIFIER      reduce using rule 6 (statement_suite -> TAB statement .)
    IF              reduce using rule 6 (statement_suite -> TAB statement .)
    FOR             reduce using rule 6 (statement_suite -> TAB statement .)
    $end            reduce using rule 6 (statement_suite -> TAB statement .)
    ELIF            reduce using rule 6 (statement_suite -> TAB statement .)
    ELSE            reduce using rule 6 (statement_suite -> TAB statement .)
    TAB             shift and go to state 72

  ! TAB             [ reduce using rule 6 (statement_suite -> TAB statement .) ]

    statement_suite                shift and go to state 81

state 77

    (17) if_stmt -> IF LPAREN arithmetic_expr RPAREN COLON statement_suite elif_stmt .

    DEF             reduce using rule 17 (if_stmt -> IF LPAREN arithmetic_expr RPAREN COLON statement_suite elif_stmt .)
    PASS            reduce using rule 17 (if_stmt -> IF LPAREN arithmetic_expr RPAREN COLON statement_suite elif_stmt .)
    RETURN          reduce using rule 17 (if_stmt -> IF LPAREN arithmetic_expr RPAREN COLON statement_suite elif_stmt .)
    IDENTIFIER      reduce using rule 17 (if_stmt -> IF LPAREN arithmetic_expr RPAREN COLON statement_suite elif_stmt .)
    IF              reduce using rule 17 (if_stmt -> IF LPAREN arithmetic_expr RPAREN COLON statement_suite elif_stmt .)
    FOR             reduce using rule 17 (if_stmt -> IF LPAREN arithmetic_expr RPAREN COLON statement_suite elif_stmt .)
    $end            reduce using rule 17 (if_stmt -> IF LPAREN arithmetic_expr RPAREN COLON statement_suite elif_stmt .)
    TAB             reduce using rule 17 (if_stmt -> IF LPAREN arithmetic_expr RPAREN COLON statement_suite elif_stmt .)
    ELIF            reduce using rule 17 (if_stmt -> IF LPAREN arithmetic_expr RPAREN COLON statement_suite elif_stmt .)
    ELSE            reduce using rule 17 (if_stmt -> IF LPAREN arithmetic_expr RPAREN COLON statement_suite elif_stmt .)


state 78

    (18) elif_stmt -> ELIF . LPAREN arithmetic_expr RPAREN COLON statement_suite else_stmt

    LPAREN          shift and go to state 82


state 79

    (19) elif_stmt -> else_stmt .

    TAB             reduce using rule 19 (elif_stmt -> else_stmt .)
    DEF             reduce using rule 19 (elif_stmt -> else_stmt .)
    PASS            reduce using rule 19 (elif_stmt -> else_stmt .)
    RETURN          reduce using rule 19 (elif_stmt -> else_stmt .)
    IDENTIFIER      reduce using rule 19 (elif_stmt -> else_stmt .)
    IF              reduce using rule 19 (elif_stmt -> else_stmt .)
    FOR             reduce using rule 19 (elif_stmt -> else_stmt .)
    $end            reduce using rule 19 (elif_stmt -> else_stmt .)
    ELIF            reduce using rule 19 (elif_stmt -> else_stmt .)
    ELSE            reduce using rule 19 (elif_stmt -> else_stmt .)


state 80

    (20) else_stmt -> ELSE . COLON statement_suite

    COLON           shift and go to state 83


state 81

    (7) statement_suite -> TAB statement statement_suite .

    DEF             reduce using rule 7 (statement_suite -> TAB statement statement_suite .)
    PASS            reduce using rule 7 (statement_suite -> TAB statement statement_suite .)
    RETURN          reduce using rule 7 (statement_suite -> TAB statement statement_suite .)
    IDENTIFIER      reduce using rule 7 (statement_suite -> TAB statement statement_suite .)
    IF              reduce using rule 7 (statement_suite -> TAB statement statement_suite .)
    FOR             reduce using rule 7 (statement_suite -> TAB statement statement_suite .)
    $end            reduce using rule 7 (statement_suite -> TAB statement statement_suite .)
    TAB             reduce using rule 7 (statement_suite -> TAB statement statement_suite .)
    ELIF            reduce using rule 7 (statement_suite -> TAB statement statement_suite .)
    ELSE            reduce using rule 7 (statement_suite -> TAB statement statement_suite .)


state 82

    (18) elif_stmt -> ELIF LPAREN . arithmetic_expr RPAREN COLON statement_suite else_stmt
    (30) arithmetic_expr -> . arithmetic_expr arithmetic_op arithmetic_expr
    (31) arithmetic_expr -> . atom
    (33) atom -> . IDENTIFIER
    (34) atom -> . literal
    (35) literal -> . NUMBER
    (36) literal -> . NONE
    (37) literal -> . TRUE
    (38) literal -> . FALSE
    (39) literal -> . STRING
    (40) literal -> . list
    (41) list -> . LSQUARE parameters RSQUARE

    IDENTIFIER      shift and go to state 39
    NUMBER          shift and go to state 28
    NONE            shift and go to state 29
    TRUE            shift and go to state 30
    FALSE           shift and go to state 31
    STRING          shift and go to state 32
    LSQUARE         shift and go to state 34

    arithmetic_expr                shift and go to state 84
    atom                           shift and go to state 25
    literal                        shift and go to state 27
    list                           shift and go to state 33

state 83

    (20) else_stmt -> ELSE COLON . statement_suite
    (6) statement_suite -> . TAB statement
    (7) statement_suite -> . TAB statement statement_suite

    TAB             shift and go to state 72

    statement_suite                shift and go to state 85

state 84

    (18) elif_stmt -> ELIF LPAREN arithmetic_expr . RPAREN COLON statement_suite else_stmt
    (30) arithmetic_expr -> arithmetic_expr . arithmetic_op arithmetic_expr
    (42) arithmetic_op -> . PLUS
    (43) arithmetic_op -> . MINUS
    (44) arithmetic_op -> . MODULUS
    (45) arithmetic_op -> . DIVIDE
    (46) arithmetic_op -> . MULTIPLY
    (47) arithmetic_op -> . GR
    (48) arithmetic_op -> . LE
    (49) arithmetic_op -> . EQ
    (50) arithmetic_op -> . GREQ
    (51) arithmetic_op -> . LEEQ

    RPAREN          shift and go to state 86
    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    MODULUS         shift and go to state 46
    DIVIDE          shift and go to state 47
    MULTIPLY        shift and go to state 48
    GR              shift and go to state 49
    LE              shift and go to state 50
    EQ              shift and go to state 51
    GREQ            shift and go to state 52
    LEEQ            shift and go to state 53

    arithmetic_op                  shift and go to state 43

state 85

    (20) else_stmt -> ELSE COLON statement_suite .

    TAB             reduce using rule 20 (else_stmt -> ELSE COLON statement_suite .)
    DEF             reduce using rule 20 (else_stmt -> ELSE COLON statement_suite .)
    PASS            reduce using rule 20 (else_stmt -> ELSE COLON statement_suite .)
    RETURN          reduce using rule 20 (else_stmt -> ELSE COLON statement_suite .)
    IDENTIFIER      reduce using rule 20 (else_stmt -> ELSE COLON statement_suite .)
    IF              reduce using rule 20 (else_stmt -> ELSE COLON statement_suite .)
    FOR             reduce using rule 20 (else_stmt -> ELSE COLON statement_suite .)
    $end            reduce using rule 20 (else_stmt -> ELSE COLON statement_suite .)
    ELIF            reduce using rule 20 (else_stmt -> ELSE COLON statement_suite .)
    ELSE            reduce using rule 20 (else_stmt -> ELSE COLON statement_suite .)


state 86

    (18) elif_stmt -> ELIF LPAREN arithmetic_expr RPAREN . COLON statement_suite else_stmt

    COLON           shift and go to state 87


state 87

    (18) elif_stmt -> ELIF LPAREN arithmetic_expr RPAREN COLON . statement_suite else_stmt
    (6) statement_suite -> . TAB statement
    (7) statement_suite -> . TAB statement statement_suite

    TAB             shift and go to state 72

    statement_suite                shift and go to state 88

state 88

    (18) elif_stmt -> ELIF LPAREN arithmetic_expr RPAREN COLON statement_suite . else_stmt
    (20) else_stmt -> . ELSE COLON statement_suite

    ELSE            shift and go to state 80

    else_stmt                      shift and go to state 89

state 89

    (18) elif_stmt -> ELIF LPAREN arithmetic_expr RPAREN COLON statement_suite else_stmt .

    TAB             reduce using rule 18 (elif_stmt -> ELIF LPAREN arithmetic_expr RPAREN COLON statement_suite else_stmt .)
    DEF             reduce using rule 18 (elif_stmt -> ELIF LPAREN arithmetic_expr RPAREN COLON statement_suite else_stmt .)
    PASS            reduce using rule 18 (elif_stmt -> ELIF LPAREN arithmetic_expr RPAREN COLON statement_suite else_stmt .)
    RETURN          reduce using rule 18 (elif_stmt -> ELIF LPAREN arithmetic_expr RPAREN COLON statement_suite else_stmt .)
    IDENTIFIER      reduce using rule 18 (elif_stmt -> ELIF LPAREN arithmetic_expr RPAREN COLON statement_suite else_stmt .)
    IF              reduce using rule 18 (elif_stmt -> ELIF LPAREN arithmetic_expr RPAREN COLON statement_suite else_stmt .)
    FOR             reduce using rule 18 (elif_stmt -> ELIF LPAREN arithmetic_expr RPAREN COLON statement_suite else_stmt .)
    $end            reduce using rule 18 (elif_stmt -> ELIF LPAREN arithmetic_expr RPAREN COLON statement_suite else_stmt .)
    ELIF            reduce using rule 18 (elif_stmt -> ELIF LPAREN arithmetic_expr RPAREN COLON statement_suite else_stmt .)
    ELSE            reduce using rule 18 (elif_stmt -> ELIF LPAREN arithmetic_expr RPAREN COLON statement_suite else_stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for RPAREN in state 37 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 61 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 61 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 61 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 61 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 61 resolved as shift
WARNING: shift/reduce conflict for GR in state 61 resolved as shift
WARNING: shift/reduce conflict for LE in state 61 resolved as shift
WARNING: shift/reduce conflict for EQ in state 61 resolved as shift
WARNING: shift/reduce conflict for GREQ in state 61 resolved as shift
WARNING: shift/reduce conflict for LEEQ in state 61 resolved as shift
WARNING: shift/reduce conflict for ELIF in state 73 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 73 resolved as shift
WARNING: shift/reduce conflict for TAB in state 76 resolved as shift
