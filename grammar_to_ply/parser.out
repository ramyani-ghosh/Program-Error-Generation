Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COLON
    LSQUARE
    RSQUARE
    STRING
    TAB
    VALUE

Grammar

Rule 0     S' -> start
Rule 1     start -> declarationList
Rule 2     declarationList -> declaration
Rule 3     declarationList -> declarationList declaration
Rule 4     declaration -> varDeclaration
Rule 5     declaration -> funcdef
Rule 6     varDeclaration -> typeSpecifier NAME SCOLON
Rule 7     varDeclaration -> typeSpecifier NAME EQUALS expressionStmt SCOLON
Rule 8     varDeclaration -> typeSpecifier NAME EQUALS NUMBER
Rule 9     varDeclaration -> typeSpecifier NAME EQUALS NAME
Rule 10    typeSpecifier -> INT
Rule 11    typeSpecifier -> BOOL
Rule 12    typeSpecifier -> CHAR
Rule 13    typeSpecifier -> FLOAT
Rule 14    funcdef -> VOID NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN
Rule 15    funcdef -> INT NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN
Rule 16    funcdef -> <empty>
Rule 17    funcdef -> FLOAT NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN
Rule 18    parameters -> typeSpecifier NAME
Rule 19    parameters -> typeSpecifier NAME COMMA parameters
Rule 20    parameters -> empty
Rule 21    funcbody -> statement
Rule 22    funcbody -> statement funcbody
Rule 23    funcbody -> statement SCOLON funcbody
Rule 24    blockitemlist -> blockitem
Rule 25    blockitemlist -> blockitemlist blockitem
Rule 26    blockitem -> statement
Rule 27    blockitem -> varDeclaration
Rule 28    cstatement -> LFPAREN RFPAREN
Rule 29    cstatement -> LFPAREN blockitemlist RFPAREN
Rule 30    statement -> cstatement
Rule 31    statement -> selectionStmt
Rule 32    statement -> iterationStmt
Rule 33    statement -> NAME SCOLON
Rule 34    statement -> NAME statement
Rule 35    statement -> varDeclaration statement
Rule 36    statement -> expressionStmt SCOLON statement
Rule 37    statement -> expressionStmt SCOLON
Rule 38    statement -> RETURN NAME SCOLON
Rule 39    expressionStmt -> NAME PLUS NAME
Rule 40    expressionStmt -> NAME MINUS NAME
Rule 41    expressionStmt -> NAME TIMES NAME
Rule 42    expressionStmt -> NAME DIVIDES NAME
Rule 43    expressionStmt -> NAME EQUALS NAME
Rule 44    expressionStmt -> NAME GREATERTHAN NAME
Rule 45    expressionStmt -> NAME LESSTHAN NAME
Rule 46    expressionStmt -> NAME GREATEQ NAME
Rule 47    expressionStmt -> NAME MODULUS NAME
Rule 48    expressionStmt -> NAME LESSEQ NAME
Rule 49    expressionStmt -> NAME EQUALS expressionStmt
Rule 50    expressionStmt -> expressionStmt EQUALEQUAL NAME
Rule 51    expressionStmt -> NAME
Rule 52    selectionStmt -> IF LPAREN expressionStmt RPAREN statement ELSE statement
Rule 53    selectionStmt -> IF LPAREN expressionStmt RPAREN statement
Rule 54    iterationStmt -> WHILE LPAREN expressionStmt RPAREN statement
Rule 55    iterationStmt -> DO statement WHILE LPAREN expressionStmt RPAREN SCOLON
Rule 56    iterationStmt -> FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement
Rule 57    forcondition -> NAME EQUALS NAME
Rule 58    forcondition -> NAME GREATERTHAN NAME
Rule 59    forcondition -> NAME LESSTHAN NAME
Rule 60    forcondition -> NAME GREATEQ NAME
Rule 61    forcondition -> NAME LESSEQ NAME
Rule 62    forchange -> NAME PLUS PLUS
Rule 63    forchange -> NAME MINUS MINUS
Rule 64    forchange -> expressionStmt
Rule 65    simp -> NAME
Rule 66    empty -> <empty>

Terminals, with rules where they appear

BOOL                 : 11
CHAR                 : 12
COLON                : 
COMMA                : 19
DIVIDES              : 42
DO                   : 55
ELSE                 : 52
EQUALEQUAL           : 50
EQUALS               : 7 8 9 43 49 57
FLOAT                : 13 17
FOR                  : 56
GREATEQ              : 46 60
GREATERTHAN          : 44 58
IF                   : 52 53
INT                  : 10 15
LESSEQ               : 48 61
LESSTHAN             : 45 59
LFPAREN              : 14 15 17 28 29
LPAREN               : 14 15 17 52 53 54 55 56
LSQUARE              : 
MINUS                : 40 63 63
MODULUS              : 47
NAME                 : 6 7 8 9 9 14 15 17 18 19 33 34 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 50 51 57 57 58 58 59 59 60 60 61 61 62 63 65
NUMBER               : 8
PLUS                 : 39 62 62
RETURN               : 38
RFPAREN              : 14 15 17 28 29
RPAREN               : 14 15 17 52 53 54 55 56
RSQUARE              : 
SCOLON               : 6 7 23 33 36 37 38 55 56 56
STRING               : 
TAB                  : 
TIMES                : 41
VALUE                : 
VOID                 : 14
WHILE                : 54 55
error                : 

Nonterminals, with rules where they appear

blockitem            : 24 25
blockitemlist        : 25 29
cstatement           : 30
declaration          : 2 3
declarationList      : 1 3
empty                : 20
expressionStmt       : 7 36 37 49 50 52 53 54 55 64
forchange            : 56
forcondition         : 56
funcbody             : 14 15 17 22 23
funcdef              : 5
iterationStmt        : 32
parameters           : 14 15 17 19
selectionStmt        : 31
simp                 : 
start                : 0
statement            : 21 22 23 26 34 35 36 52 52 53 54 55 56
typeSpecifier        : 6 7 8 9 18 19
varDeclaration       : 4 27 35 56

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . declarationList
    (2) declarationList -> . declaration
    (3) declarationList -> . declarationList declaration
    (4) declaration -> . varDeclaration
    (5) declaration -> . funcdef
    (6) varDeclaration -> . typeSpecifier NAME SCOLON
    (7) varDeclaration -> . typeSpecifier NAME EQUALS expressionStmt SCOLON
    (8) varDeclaration -> . typeSpecifier NAME EQUALS NUMBER
    (9) varDeclaration -> . typeSpecifier NAME EQUALS NAME
    (14) funcdef -> . VOID NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN
    (15) funcdef -> . INT NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN
    (16) funcdef -> .
    (17) funcdef -> . FLOAT NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN
    (10) typeSpecifier -> . INT
    (11) typeSpecifier -> . BOOL
    (12) typeSpecifier -> . CHAR
    (13) typeSpecifier -> . FLOAT

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
    VOID            shift and go to state 7
    INT             shift and go to state 8
    $end            reduce using rule 16 (funcdef -> .)
    FLOAT           shift and go to state 9
    BOOL            shift and go to state 10
    CHAR            shift and go to state 11

  ! VOID            [ reduce using rule 16 (funcdef -> .) ]
  ! INT             [ reduce using rule 16 (funcdef -> .) ]
  ! FLOAT           [ reduce using rule 16 (funcdef -> .) ]
  ! BOOL            [ reduce using rule 16 (funcdef -> .) ]
  ! CHAR            [ reduce using rule 16 (funcdef -> .) ]

    start                          shift and go to state 1
    declarationList                shift and go to state 2
    declaration                    shift and go to state 3
    varDeclaration                 shift and go to state 4
    funcdef                        shift and go to state 5
    typeSpecifier                  shift and go to state 6

state 1

    (0) S' -> start .



state 2

    (1) start -> declarationList .
    (3) declarationList -> declarationList . declaration
    (4) declaration -> . varDeclaration
    (5) declaration -> . funcdef
    (6) varDeclaration -> . typeSpecifier NAME SCOLON
    (7) varDeclaration -> . typeSpecifier NAME EQUALS expressionStmt SCOLON
    (8) varDeclaration -> . typeSpecifier NAME EQUALS NUMBER
    (9) varDeclaration -> . typeSpecifier NAME EQUALS NAME
    (14) funcdef -> . VOID NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN
    (15) funcdef -> . INT NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN
    (16) funcdef -> .
    (17) funcdef -> . FLOAT NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN
    (10) typeSpecifier -> . INT
    (11) typeSpecifier -> . BOOL
    (12) typeSpecifier -> . CHAR
    (13) typeSpecifier -> . FLOAT

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 1 (start -> declarationList .)
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
    $end            reduce using rule 1 (start -> declarationList .)
    VOID            shift and go to state 7
    INT             shift and go to state 8
    FLOAT           shift and go to state 9
    BOOL            shift and go to state 10
    CHAR            shift and go to state 11

  ! VOID            [ reduce using rule 16 (funcdef -> .) ]
  ! INT             [ reduce using rule 16 (funcdef -> .) ]
  ! FLOAT           [ reduce using rule 16 (funcdef -> .) ]
  ! BOOL            [ reduce using rule 16 (funcdef -> .) ]
  ! CHAR            [ reduce using rule 16 (funcdef -> .) ]
  ! $end            [ reduce using rule 16 (funcdef -> .) ]

    declaration                    shift and go to state 12
    varDeclaration                 shift and go to state 4
    funcdef                        shift and go to state 5
    typeSpecifier                  shift and go to state 6

state 3

    (2) declarationList -> declaration .

    VOID            reduce using rule 2 (declarationList -> declaration .)
    INT             reduce using rule 2 (declarationList -> declaration .)
    FLOAT           reduce using rule 2 (declarationList -> declaration .)
    BOOL            reduce using rule 2 (declarationList -> declaration .)
    CHAR            reduce using rule 2 (declarationList -> declaration .)
    $end            reduce using rule 2 (declarationList -> declaration .)


state 4

    (4) declaration -> varDeclaration .

    VOID            reduce using rule 4 (declaration -> varDeclaration .)
    INT             reduce using rule 4 (declaration -> varDeclaration .)
    FLOAT           reduce using rule 4 (declaration -> varDeclaration .)
    BOOL            reduce using rule 4 (declaration -> varDeclaration .)
    CHAR            reduce using rule 4 (declaration -> varDeclaration .)
    $end            reduce using rule 4 (declaration -> varDeclaration .)


state 5

    (5) declaration -> funcdef .

    VOID            reduce using rule 5 (declaration -> funcdef .)
    INT             reduce using rule 5 (declaration -> funcdef .)
    FLOAT           reduce using rule 5 (declaration -> funcdef .)
    BOOL            reduce using rule 5 (declaration -> funcdef .)
    CHAR            reduce using rule 5 (declaration -> funcdef .)
    $end            reduce using rule 5 (declaration -> funcdef .)


state 6

    (6) varDeclaration -> typeSpecifier . NAME SCOLON
    (7) varDeclaration -> typeSpecifier . NAME EQUALS expressionStmt SCOLON
    (8) varDeclaration -> typeSpecifier . NAME EQUALS NUMBER
    (9) varDeclaration -> typeSpecifier . NAME EQUALS NAME

    NAME            shift and go to state 13


state 7

    (14) funcdef -> VOID . NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN

    NAME            shift and go to state 14


state 8

    (15) funcdef -> INT . NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN
    (10) typeSpecifier -> INT .

  ! shift/reduce conflict for NAME resolved as shift
    NAME            shift and go to state 15

  ! NAME            [ reduce using rule 10 (typeSpecifier -> INT .) ]


state 9

    (17) funcdef -> FLOAT . NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN
    (13) typeSpecifier -> FLOAT .

  ! shift/reduce conflict for NAME resolved as shift
    NAME            shift and go to state 16

  ! NAME            [ reduce using rule 13 (typeSpecifier -> FLOAT .) ]


state 10

    (11) typeSpecifier -> BOOL .

    NAME            reduce using rule 11 (typeSpecifier -> BOOL .)


state 11

    (12) typeSpecifier -> CHAR .

    NAME            reduce using rule 12 (typeSpecifier -> CHAR .)


state 12

    (3) declarationList -> declarationList declaration .

    VOID            reduce using rule 3 (declarationList -> declarationList declaration .)
    INT             reduce using rule 3 (declarationList -> declarationList declaration .)
    FLOAT           reduce using rule 3 (declarationList -> declarationList declaration .)
    BOOL            reduce using rule 3 (declarationList -> declarationList declaration .)
    CHAR            reduce using rule 3 (declarationList -> declarationList declaration .)
    $end            reduce using rule 3 (declarationList -> declarationList declaration .)


state 13

    (6) varDeclaration -> typeSpecifier NAME . SCOLON
    (7) varDeclaration -> typeSpecifier NAME . EQUALS expressionStmt SCOLON
    (8) varDeclaration -> typeSpecifier NAME . EQUALS NUMBER
    (9) varDeclaration -> typeSpecifier NAME . EQUALS NAME

    SCOLON          shift and go to state 17
    EQUALS          shift and go to state 18


state 14

    (14) funcdef -> VOID NAME . LPAREN parameters RPAREN LFPAREN funcbody RFPAREN

    LPAREN          shift and go to state 19


state 15

    (15) funcdef -> INT NAME . LPAREN parameters RPAREN LFPAREN funcbody RFPAREN

    LPAREN          shift and go to state 20


state 16

    (17) funcdef -> FLOAT NAME . LPAREN parameters RPAREN LFPAREN funcbody RFPAREN

    LPAREN          shift and go to state 21


state 17

    (6) varDeclaration -> typeSpecifier NAME SCOLON .

    VOID            reduce using rule 6 (varDeclaration -> typeSpecifier NAME SCOLON .)
    INT             reduce using rule 6 (varDeclaration -> typeSpecifier NAME SCOLON .)
    FLOAT           reduce using rule 6 (varDeclaration -> typeSpecifier NAME SCOLON .)
    BOOL            reduce using rule 6 (varDeclaration -> typeSpecifier NAME SCOLON .)
    CHAR            reduce using rule 6 (varDeclaration -> typeSpecifier NAME SCOLON .)
    $end            reduce using rule 6 (varDeclaration -> typeSpecifier NAME SCOLON .)
    NAME            reduce using rule 6 (varDeclaration -> typeSpecifier NAME SCOLON .)
    RETURN          reduce using rule 6 (varDeclaration -> typeSpecifier NAME SCOLON .)
    LFPAREN         reduce using rule 6 (varDeclaration -> typeSpecifier NAME SCOLON .)
    IF              reduce using rule 6 (varDeclaration -> typeSpecifier NAME SCOLON .)
    WHILE           reduce using rule 6 (varDeclaration -> typeSpecifier NAME SCOLON .)
    DO              reduce using rule 6 (varDeclaration -> typeSpecifier NAME SCOLON .)
    FOR             reduce using rule 6 (varDeclaration -> typeSpecifier NAME SCOLON .)
    RFPAREN         reduce using rule 6 (varDeclaration -> typeSpecifier NAME SCOLON .)
    SCOLON          reduce using rule 6 (varDeclaration -> typeSpecifier NAME SCOLON .)


state 18

    (7) varDeclaration -> typeSpecifier NAME EQUALS . expressionStmt SCOLON
    (8) varDeclaration -> typeSpecifier NAME EQUALS . NUMBER
    (9) varDeclaration -> typeSpecifier NAME EQUALS . NAME
    (39) expressionStmt -> . NAME PLUS NAME
    (40) expressionStmt -> . NAME MINUS NAME
    (41) expressionStmt -> . NAME TIMES NAME
    (42) expressionStmt -> . NAME DIVIDES NAME
    (43) expressionStmt -> . NAME EQUALS NAME
    (44) expressionStmt -> . NAME GREATERTHAN NAME
    (45) expressionStmt -> . NAME LESSTHAN NAME
    (46) expressionStmt -> . NAME GREATEQ NAME
    (47) expressionStmt -> . NAME MODULUS NAME
    (48) expressionStmt -> . NAME LESSEQ NAME
    (49) expressionStmt -> . NAME EQUALS expressionStmt
    (50) expressionStmt -> . expressionStmt EQUALEQUAL NAME
    (51) expressionStmt -> . NAME

    NUMBER          shift and go to state 24
    NAME            shift and go to state 22

    expressionStmt                 shift and go to state 23

state 19

    (14) funcdef -> VOID NAME LPAREN . parameters RPAREN LFPAREN funcbody RFPAREN
    (18) parameters -> . typeSpecifier NAME
    (19) parameters -> . typeSpecifier NAME COMMA parameters
    (20) parameters -> . empty
    (10) typeSpecifier -> . INT
    (11) typeSpecifier -> . BOOL
    (12) typeSpecifier -> . CHAR
    (13) typeSpecifier -> . FLOAT
    (66) empty -> .

    INT             shift and go to state 28
    BOOL            shift and go to state 10
    CHAR            shift and go to state 11
    FLOAT           shift and go to state 29
    RPAREN          reduce using rule 66 (empty -> .)

    parameters                     shift and go to state 25
    typeSpecifier                  shift and go to state 26
    empty                          shift and go to state 27

state 20

    (15) funcdef -> INT NAME LPAREN . parameters RPAREN LFPAREN funcbody RFPAREN
    (18) parameters -> . typeSpecifier NAME
    (19) parameters -> . typeSpecifier NAME COMMA parameters
    (20) parameters -> . empty
    (10) typeSpecifier -> . INT
    (11) typeSpecifier -> . BOOL
    (12) typeSpecifier -> . CHAR
    (13) typeSpecifier -> . FLOAT
    (66) empty -> .

    INT             shift and go to state 28
    BOOL            shift and go to state 10
    CHAR            shift and go to state 11
    FLOAT           shift and go to state 29
    RPAREN          reduce using rule 66 (empty -> .)

    parameters                     shift and go to state 30
    typeSpecifier                  shift and go to state 26
    empty                          shift and go to state 27

state 21

    (17) funcdef -> FLOAT NAME LPAREN . parameters RPAREN LFPAREN funcbody RFPAREN
    (18) parameters -> . typeSpecifier NAME
    (19) parameters -> . typeSpecifier NAME COMMA parameters
    (20) parameters -> . empty
    (10) typeSpecifier -> . INT
    (11) typeSpecifier -> . BOOL
    (12) typeSpecifier -> . CHAR
    (13) typeSpecifier -> . FLOAT
    (66) empty -> .

    INT             shift and go to state 28
    BOOL            shift and go to state 10
    CHAR            shift and go to state 11
    FLOAT           shift and go to state 29
    RPAREN          reduce using rule 66 (empty -> .)

    parameters                     shift and go to state 31
    typeSpecifier                  shift and go to state 26
    empty                          shift and go to state 27

state 22

    (9) varDeclaration -> typeSpecifier NAME EQUALS NAME .
    (39) expressionStmt -> NAME . PLUS NAME
    (40) expressionStmt -> NAME . MINUS NAME
    (41) expressionStmt -> NAME . TIMES NAME
    (42) expressionStmt -> NAME . DIVIDES NAME
    (43) expressionStmt -> NAME . EQUALS NAME
    (44) expressionStmt -> NAME . GREATERTHAN NAME
    (45) expressionStmt -> NAME . LESSTHAN NAME
    (46) expressionStmt -> NAME . GREATEQ NAME
    (47) expressionStmt -> NAME . MODULUS NAME
    (48) expressionStmt -> NAME . LESSEQ NAME
    (49) expressionStmt -> NAME . EQUALS expressionStmt
    (51) expressionStmt -> NAME .

  ! reduce/reduce conflict for SCOLON resolved using rule 9 (varDeclaration -> typeSpecifier NAME EQUALS NAME .)
    VOID            reduce using rule 9 (varDeclaration -> typeSpecifier NAME EQUALS NAME .)
    INT             reduce using rule 9 (varDeclaration -> typeSpecifier NAME EQUALS NAME .)
    FLOAT           reduce using rule 9 (varDeclaration -> typeSpecifier NAME EQUALS NAME .)
    BOOL            reduce using rule 9 (varDeclaration -> typeSpecifier NAME EQUALS NAME .)
    CHAR            reduce using rule 9 (varDeclaration -> typeSpecifier NAME EQUALS NAME .)
    $end            reduce using rule 9 (varDeclaration -> typeSpecifier NAME EQUALS NAME .)
    NAME            reduce using rule 9 (varDeclaration -> typeSpecifier NAME EQUALS NAME .)
    RETURN          reduce using rule 9 (varDeclaration -> typeSpecifier NAME EQUALS NAME .)
    LFPAREN         reduce using rule 9 (varDeclaration -> typeSpecifier NAME EQUALS NAME .)
    IF              reduce using rule 9 (varDeclaration -> typeSpecifier NAME EQUALS NAME .)
    WHILE           reduce using rule 9 (varDeclaration -> typeSpecifier NAME EQUALS NAME .)
    DO              reduce using rule 9 (varDeclaration -> typeSpecifier NAME EQUALS NAME .)
    FOR             reduce using rule 9 (varDeclaration -> typeSpecifier NAME EQUALS NAME .)
    RFPAREN         reduce using rule 9 (varDeclaration -> typeSpecifier NAME EQUALS NAME .)
    SCOLON          reduce using rule 9 (varDeclaration -> typeSpecifier NAME EQUALS NAME .)
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDES         shift and go to state 36
    EQUALS          shift and go to state 32
    GREATERTHAN     shift and go to state 37
    LESSTHAN        shift and go to state 38
    GREATEQ         shift and go to state 39
    MODULUS         shift and go to state 40
    LESSEQ          shift and go to state 41
    EQUALEQUAL      reduce using rule 51 (expressionStmt -> NAME .)

  ! SCOLON          [ reduce using rule 51 (expressionStmt -> NAME .) ]


state 23

    (7) varDeclaration -> typeSpecifier NAME EQUALS expressionStmt . SCOLON
    (50) expressionStmt -> expressionStmt . EQUALEQUAL NAME

    SCOLON          shift and go to state 42
    EQUALEQUAL      shift and go to state 43


state 24

    (8) varDeclaration -> typeSpecifier NAME EQUALS NUMBER .

    VOID            reduce using rule 8 (varDeclaration -> typeSpecifier NAME EQUALS NUMBER .)
    INT             reduce using rule 8 (varDeclaration -> typeSpecifier NAME EQUALS NUMBER .)
    FLOAT           reduce using rule 8 (varDeclaration -> typeSpecifier NAME EQUALS NUMBER .)
    BOOL            reduce using rule 8 (varDeclaration -> typeSpecifier NAME EQUALS NUMBER .)
    CHAR            reduce using rule 8 (varDeclaration -> typeSpecifier NAME EQUALS NUMBER .)
    $end            reduce using rule 8 (varDeclaration -> typeSpecifier NAME EQUALS NUMBER .)
    NAME            reduce using rule 8 (varDeclaration -> typeSpecifier NAME EQUALS NUMBER .)
    RETURN          reduce using rule 8 (varDeclaration -> typeSpecifier NAME EQUALS NUMBER .)
    LFPAREN         reduce using rule 8 (varDeclaration -> typeSpecifier NAME EQUALS NUMBER .)
    IF              reduce using rule 8 (varDeclaration -> typeSpecifier NAME EQUALS NUMBER .)
    WHILE           reduce using rule 8 (varDeclaration -> typeSpecifier NAME EQUALS NUMBER .)
    DO              reduce using rule 8 (varDeclaration -> typeSpecifier NAME EQUALS NUMBER .)
    FOR             reduce using rule 8 (varDeclaration -> typeSpecifier NAME EQUALS NUMBER .)
    RFPAREN         reduce using rule 8 (varDeclaration -> typeSpecifier NAME EQUALS NUMBER .)
    SCOLON          reduce using rule 8 (varDeclaration -> typeSpecifier NAME EQUALS NUMBER .)


state 25

    (14) funcdef -> VOID NAME LPAREN parameters . RPAREN LFPAREN funcbody RFPAREN

    RPAREN          shift and go to state 44


state 26

    (18) parameters -> typeSpecifier . NAME
    (19) parameters -> typeSpecifier . NAME COMMA parameters

    NAME            shift and go to state 45


state 27

    (20) parameters -> empty .

    RPAREN          reduce using rule 20 (parameters -> empty .)


state 28

    (10) typeSpecifier -> INT .

    NAME            reduce using rule 10 (typeSpecifier -> INT .)


state 29

    (13) typeSpecifier -> FLOAT .

    NAME            reduce using rule 13 (typeSpecifier -> FLOAT .)


state 30

    (15) funcdef -> INT NAME LPAREN parameters . RPAREN LFPAREN funcbody RFPAREN

    RPAREN          shift and go to state 46


state 31

    (17) funcdef -> FLOAT NAME LPAREN parameters . RPAREN LFPAREN funcbody RFPAREN

    RPAREN          shift and go to state 47


state 32

    (43) expressionStmt -> NAME EQUALS . NAME
    (49) expressionStmt -> NAME EQUALS . expressionStmt
    (39) expressionStmt -> . NAME PLUS NAME
    (40) expressionStmt -> . NAME MINUS NAME
    (41) expressionStmt -> . NAME TIMES NAME
    (42) expressionStmt -> . NAME DIVIDES NAME
    (43) expressionStmt -> . NAME EQUALS NAME
    (44) expressionStmt -> . NAME GREATERTHAN NAME
    (45) expressionStmt -> . NAME LESSTHAN NAME
    (46) expressionStmt -> . NAME GREATEQ NAME
    (47) expressionStmt -> . NAME MODULUS NAME
    (48) expressionStmt -> . NAME LESSEQ NAME
    (49) expressionStmt -> . NAME EQUALS expressionStmt
    (50) expressionStmt -> . expressionStmt EQUALEQUAL NAME
    (51) expressionStmt -> . NAME

    NAME            shift and go to state 48

    expressionStmt                 shift and go to state 49

state 33

    (39) expressionStmt -> NAME PLUS . NAME

    NAME            shift and go to state 50


state 34

    (40) expressionStmt -> NAME MINUS . NAME

    NAME            shift and go to state 51


state 35

    (41) expressionStmt -> NAME TIMES . NAME

    NAME            shift and go to state 52


state 36

    (42) expressionStmt -> NAME DIVIDES . NAME

    NAME            shift and go to state 53


state 37

    (44) expressionStmt -> NAME GREATERTHAN . NAME

    NAME            shift and go to state 54


state 38

    (45) expressionStmt -> NAME LESSTHAN . NAME

    NAME            shift and go to state 55


state 39

    (46) expressionStmt -> NAME GREATEQ . NAME

    NAME            shift and go to state 56


state 40

    (47) expressionStmt -> NAME MODULUS . NAME

    NAME            shift and go to state 57


state 41

    (48) expressionStmt -> NAME LESSEQ . NAME

    NAME            shift and go to state 58


state 42

    (7) varDeclaration -> typeSpecifier NAME EQUALS expressionStmt SCOLON .

    VOID            reduce using rule 7 (varDeclaration -> typeSpecifier NAME EQUALS expressionStmt SCOLON .)
    INT             reduce using rule 7 (varDeclaration -> typeSpecifier NAME EQUALS expressionStmt SCOLON .)
    FLOAT           reduce using rule 7 (varDeclaration -> typeSpecifier NAME EQUALS expressionStmt SCOLON .)
    BOOL            reduce using rule 7 (varDeclaration -> typeSpecifier NAME EQUALS expressionStmt SCOLON .)
    CHAR            reduce using rule 7 (varDeclaration -> typeSpecifier NAME EQUALS expressionStmt SCOLON .)
    $end            reduce using rule 7 (varDeclaration -> typeSpecifier NAME EQUALS expressionStmt SCOLON .)
    NAME            reduce using rule 7 (varDeclaration -> typeSpecifier NAME EQUALS expressionStmt SCOLON .)
    RETURN          reduce using rule 7 (varDeclaration -> typeSpecifier NAME EQUALS expressionStmt SCOLON .)
    LFPAREN         reduce using rule 7 (varDeclaration -> typeSpecifier NAME EQUALS expressionStmt SCOLON .)
    IF              reduce using rule 7 (varDeclaration -> typeSpecifier NAME EQUALS expressionStmt SCOLON .)
    WHILE           reduce using rule 7 (varDeclaration -> typeSpecifier NAME EQUALS expressionStmt SCOLON .)
    DO              reduce using rule 7 (varDeclaration -> typeSpecifier NAME EQUALS expressionStmt SCOLON .)
    FOR             reduce using rule 7 (varDeclaration -> typeSpecifier NAME EQUALS expressionStmt SCOLON .)
    RFPAREN         reduce using rule 7 (varDeclaration -> typeSpecifier NAME EQUALS expressionStmt SCOLON .)
    SCOLON          reduce using rule 7 (varDeclaration -> typeSpecifier NAME EQUALS expressionStmt SCOLON .)


state 43

    (50) expressionStmt -> expressionStmt EQUALEQUAL . NAME

    NAME            shift and go to state 59


state 44

    (14) funcdef -> VOID NAME LPAREN parameters RPAREN . LFPAREN funcbody RFPAREN

    LFPAREN         shift and go to state 60


state 45

    (18) parameters -> typeSpecifier NAME .
    (19) parameters -> typeSpecifier NAME . COMMA parameters

    RPAREN          reduce using rule 18 (parameters -> typeSpecifier NAME .)
    COMMA           shift and go to state 61


state 46

    (15) funcdef -> INT NAME LPAREN parameters RPAREN . LFPAREN funcbody RFPAREN

    LFPAREN         shift and go to state 62


state 47

    (17) funcdef -> FLOAT NAME LPAREN parameters RPAREN . LFPAREN funcbody RFPAREN

    LFPAREN         shift and go to state 63


state 48

    (43) expressionStmt -> NAME EQUALS NAME .
    (39) expressionStmt -> NAME . PLUS NAME
    (40) expressionStmt -> NAME . MINUS NAME
    (41) expressionStmt -> NAME . TIMES NAME
    (42) expressionStmt -> NAME . DIVIDES NAME
    (43) expressionStmt -> NAME . EQUALS NAME
    (44) expressionStmt -> NAME . GREATERTHAN NAME
    (45) expressionStmt -> NAME . LESSTHAN NAME
    (46) expressionStmt -> NAME . GREATEQ NAME
    (47) expressionStmt -> NAME . MODULUS NAME
    (48) expressionStmt -> NAME . LESSEQ NAME
    (49) expressionStmt -> NAME . EQUALS expressionStmt
    (51) expressionStmt -> NAME .

  ! reduce/reduce conflict for EQUALEQUAL resolved using rule 43 (expressionStmt -> NAME EQUALS NAME .)
  ! reduce/reduce conflict for SCOLON resolved using rule 43 (expressionStmt -> NAME EQUALS NAME .)
  ! reduce/reduce conflict for RPAREN resolved using rule 43 (expressionStmt -> NAME EQUALS NAME .)
    SCOLON          reduce using rule 43 (expressionStmt -> NAME EQUALS NAME .)
    EQUALEQUAL      reduce using rule 43 (expressionStmt -> NAME EQUALS NAME .)
    RPAREN          reduce using rule 43 (expressionStmt -> NAME EQUALS NAME .)
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDES         shift and go to state 36
    EQUALS          shift and go to state 32
    GREATERTHAN     shift and go to state 37
    LESSTHAN        shift and go to state 38
    GREATEQ         shift and go to state 39
    MODULUS         shift and go to state 40
    LESSEQ          shift and go to state 41

  ! EQUALEQUAL      [ reduce using rule 51 (expressionStmt -> NAME .) ]
  ! SCOLON          [ reduce using rule 51 (expressionStmt -> NAME .) ]
  ! RPAREN          [ reduce using rule 51 (expressionStmt -> NAME .) ]


state 49

    (49) expressionStmt -> NAME EQUALS expressionStmt .
    (50) expressionStmt -> expressionStmt . EQUALEQUAL NAME

  ! shift/reduce conflict for EQUALEQUAL resolved as shift
    SCOLON          reduce using rule 49 (expressionStmt -> NAME EQUALS expressionStmt .)
    RPAREN          reduce using rule 49 (expressionStmt -> NAME EQUALS expressionStmt .)
    EQUALEQUAL      shift and go to state 43

  ! EQUALEQUAL      [ reduce using rule 49 (expressionStmt -> NAME EQUALS expressionStmt .) ]


state 50

    (39) expressionStmt -> NAME PLUS NAME .

    SCOLON          reduce using rule 39 (expressionStmt -> NAME PLUS NAME .)
    EQUALEQUAL      reduce using rule 39 (expressionStmt -> NAME PLUS NAME .)
    RPAREN          reduce using rule 39 (expressionStmt -> NAME PLUS NAME .)


state 51

    (40) expressionStmt -> NAME MINUS NAME .

    SCOLON          reduce using rule 40 (expressionStmt -> NAME MINUS NAME .)
    EQUALEQUAL      reduce using rule 40 (expressionStmt -> NAME MINUS NAME .)
    RPAREN          reduce using rule 40 (expressionStmt -> NAME MINUS NAME .)


state 52

    (41) expressionStmt -> NAME TIMES NAME .

    SCOLON          reduce using rule 41 (expressionStmt -> NAME TIMES NAME .)
    EQUALEQUAL      reduce using rule 41 (expressionStmt -> NAME TIMES NAME .)
    RPAREN          reduce using rule 41 (expressionStmt -> NAME TIMES NAME .)


state 53

    (42) expressionStmt -> NAME DIVIDES NAME .

    SCOLON          reduce using rule 42 (expressionStmt -> NAME DIVIDES NAME .)
    EQUALEQUAL      reduce using rule 42 (expressionStmt -> NAME DIVIDES NAME .)
    RPAREN          reduce using rule 42 (expressionStmt -> NAME DIVIDES NAME .)


state 54

    (44) expressionStmt -> NAME GREATERTHAN NAME .

    SCOLON          reduce using rule 44 (expressionStmt -> NAME GREATERTHAN NAME .)
    EQUALEQUAL      reduce using rule 44 (expressionStmt -> NAME GREATERTHAN NAME .)
    RPAREN          reduce using rule 44 (expressionStmt -> NAME GREATERTHAN NAME .)


state 55

    (45) expressionStmt -> NAME LESSTHAN NAME .

    SCOLON          reduce using rule 45 (expressionStmt -> NAME LESSTHAN NAME .)
    EQUALEQUAL      reduce using rule 45 (expressionStmt -> NAME LESSTHAN NAME .)
    RPAREN          reduce using rule 45 (expressionStmt -> NAME LESSTHAN NAME .)


state 56

    (46) expressionStmt -> NAME GREATEQ NAME .

    SCOLON          reduce using rule 46 (expressionStmt -> NAME GREATEQ NAME .)
    EQUALEQUAL      reduce using rule 46 (expressionStmt -> NAME GREATEQ NAME .)
    RPAREN          reduce using rule 46 (expressionStmt -> NAME GREATEQ NAME .)


state 57

    (47) expressionStmt -> NAME MODULUS NAME .

    SCOLON          reduce using rule 47 (expressionStmt -> NAME MODULUS NAME .)
    EQUALEQUAL      reduce using rule 47 (expressionStmt -> NAME MODULUS NAME .)
    RPAREN          reduce using rule 47 (expressionStmt -> NAME MODULUS NAME .)


state 58

    (48) expressionStmt -> NAME LESSEQ NAME .

    SCOLON          reduce using rule 48 (expressionStmt -> NAME LESSEQ NAME .)
    EQUALEQUAL      reduce using rule 48 (expressionStmt -> NAME LESSEQ NAME .)
    RPAREN          reduce using rule 48 (expressionStmt -> NAME LESSEQ NAME .)


state 59

    (50) expressionStmt -> expressionStmt EQUALEQUAL NAME .

    SCOLON          reduce using rule 50 (expressionStmt -> expressionStmt EQUALEQUAL NAME .)
    EQUALEQUAL      reduce using rule 50 (expressionStmt -> expressionStmt EQUALEQUAL NAME .)
    RPAREN          reduce using rule 50 (expressionStmt -> expressionStmt EQUALEQUAL NAME .)


state 60

    (14) funcdef -> VOID NAME LPAREN parameters RPAREN LFPAREN . funcbody RFPAREN
    (21) funcbody -> . statement
    (22) funcbody -> . statement funcbody
    (23) funcbody -> . statement SCOLON funcbody
    (30) statement -> . cstatement
    (31) statement -> . selectionStmt
    (32) statement -> . iterationStmt
    (33) statement -> . NAME SCOLON
    (34) statement -> . NAME statement
    (35) statement -> . varDeclaration statement
    (36) statement -> . expressionStmt SCOLON statement
    (37) statement -> . expressionStmt SCOLON
    (38) statement -> . RETURN NAME SCOLON
    (28) cstatement -> . LFPAREN RFPAREN
    (29) cstatement -> . LFPAREN blockitemlist RFPAREN
    (52) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement ELSE statement
    (53) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement
    (54) iterationStmt -> . WHILE LPAREN expressionStmt RPAREN statement
    (55) iterationStmt -> . DO statement WHILE LPAREN expressionStmt RPAREN SCOLON
    (56) iterationStmt -> . FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement
    (6) varDeclaration -> . typeSpecifier NAME SCOLON
    (7) varDeclaration -> . typeSpecifier NAME EQUALS expressionStmt SCOLON
    (8) varDeclaration -> . typeSpecifier NAME EQUALS NUMBER
    (9) varDeclaration -> . typeSpecifier NAME EQUALS NAME
    (39) expressionStmt -> . NAME PLUS NAME
    (40) expressionStmt -> . NAME MINUS NAME
    (41) expressionStmt -> . NAME TIMES NAME
    (42) expressionStmt -> . NAME DIVIDES NAME
    (43) expressionStmt -> . NAME EQUALS NAME
    (44) expressionStmt -> . NAME GREATERTHAN NAME
    (45) expressionStmt -> . NAME LESSTHAN NAME
    (46) expressionStmt -> . NAME GREATEQ NAME
    (47) expressionStmt -> . NAME MODULUS NAME
    (48) expressionStmt -> . NAME LESSEQ NAME
    (49) expressionStmt -> . NAME EQUALS expressionStmt
    (50) expressionStmt -> . expressionStmt EQUALEQUAL NAME
    (51) expressionStmt -> . NAME
    (10) typeSpecifier -> . INT
    (11) typeSpecifier -> . BOOL
    (12) typeSpecifier -> . CHAR
    (13) typeSpecifier -> . FLOAT

    NAME            shift and go to state 64
    RETURN          shift and go to state 73
    LFPAREN         shift and go to state 65
    IF              shift and go to state 74
    WHILE           shift and go to state 75
    DO              shift and go to state 76
    FOR             shift and go to state 77
    INT             shift and go to state 28
    BOOL            shift and go to state 10
    CHAR            shift and go to state 11
    FLOAT           shift and go to state 29

    funcbody                       shift and go to state 66
    statement                      shift and go to state 67
    cstatement                     shift and go to state 68
    selectionStmt                  shift and go to state 69
    iterationStmt                  shift and go to state 70
    varDeclaration                 shift and go to state 71
    expressionStmt                 shift and go to state 72
    typeSpecifier                  shift and go to state 6

state 61

    (19) parameters -> typeSpecifier NAME COMMA . parameters
    (18) parameters -> . typeSpecifier NAME
    (19) parameters -> . typeSpecifier NAME COMMA parameters
    (20) parameters -> . empty
    (10) typeSpecifier -> . INT
    (11) typeSpecifier -> . BOOL
    (12) typeSpecifier -> . CHAR
    (13) typeSpecifier -> . FLOAT
    (66) empty -> .

    INT             shift and go to state 28
    BOOL            shift and go to state 10
    CHAR            shift and go to state 11
    FLOAT           shift and go to state 29
    RPAREN          reduce using rule 66 (empty -> .)

    typeSpecifier                  shift and go to state 26
    parameters                     shift and go to state 78
    empty                          shift and go to state 27

state 62

    (15) funcdef -> INT NAME LPAREN parameters RPAREN LFPAREN . funcbody RFPAREN
    (21) funcbody -> . statement
    (22) funcbody -> . statement funcbody
    (23) funcbody -> . statement SCOLON funcbody
    (30) statement -> . cstatement
    (31) statement -> . selectionStmt
    (32) statement -> . iterationStmt
    (33) statement -> . NAME SCOLON
    (34) statement -> . NAME statement
    (35) statement -> . varDeclaration statement
    (36) statement -> . expressionStmt SCOLON statement
    (37) statement -> . expressionStmt SCOLON
    (38) statement -> . RETURN NAME SCOLON
    (28) cstatement -> . LFPAREN RFPAREN
    (29) cstatement -> . LFPAREN blockitemlist RFPAREN
    (52) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement ELSE statement
    (53) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement
    (54) iterationStmt -> . WHILE LPAREN expressionStmt RPAREN statement
    (55) iterationStmt -> . DO statement WHILE LPAREN expressionStmt RPAREN SCOLON
    (56) iterationStmt -> . FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement
    (6) varDeclaration -> . typeSpecifier NAME SCOLON
    (7) varDeclaration -> . typeSpecifier NAME EQUALS expressionStmt SCOLON
    (8) varDeclaration -> . typeSpecifier NAME EQUALS NUMBER
    (9) varDeclaration -> . typeSpecifier NAME EQUALS NAME
    (39) expressionStmt -> . NAME PLUS NAME
    (40) expressionStmt -> . NAME MINUS NAME
    (41) expressionStmt -> . NAME TIMES NAME
    (42) expressionStmt -> . NAME DIVIDES NAME
    (43) expressionStmt -> . NAME EQUALS NAME
    (44) expressionStmt -> . NAME GREATERTHAN NAME
    (45) expressionStmt -> . NAME LESSTHAN NAME
    (46) expressionStmt -> . NAME GREATEQ NAME
    (47) expressionStmt -> . NAME MODULUS NAME
    (48) expressionStmt -> . NAME LESSEQ NAME
    (49) expressionStmt -> . NAME EQUALS expressionStmt
    (50) expressionStmt -> . expressionStmt EQUALEQUAL NAME
    (51) expressionStmt -> . NAME
    (10) typeSpecifier -> . INT
    (11) typeSpecifier -> . BOOL
    (12) typeSpecifier -> . CHAR
    (13) typeSpecifier -> . FLOAT

    NAME            shift and go to state 64
    RETURN          shift and go to state 73
    LFPAREN         shift and go to state 65
    IF              shift and go to state 74
    WHILE           shift and go to state 75
    DO              shift and go to state 76
    FOR             shift and go to state 77
    INT             shift and go to state 28
    BOOL            shift and go to state 10
    CHAR            shift and go to state 11
    FLOAT           shift and go to state 29

    funcbody                       shift and go to state 79
    statement                      shift and go to state 67
    cstatement                     shift and go to state 68
    selectionStmt                  shift and go to state 69
    iterationStmt                  shift and go to state 70
    varDeclaration                 shift and go to state 71
    expressionStmt                 shift and go to state 72
    typeSpecifier                  shift and go to state 6

state 63

    (17) funcdef -> FLOAT NAME LPAREN parameters RPAREN LFPAREN . funcbody RFPAREN
    (21) funcbody -> . statement
    (22) funcbody -> . statement funcbody
    (23) funcbody -> . statement SCOLON funcbody
    (30) statement -> . cstatement
    (31) statement -> . selectionStmt
    (32) statement -> . iterationStmt
    (33) statement -> . NAME SCOLON
    (34) statement -> . NAME statement
    (35) statement -> . varDeclaration statement
    (36) statement -> . expressionStmt SCOLON statement
    (37) statement -> . expressionStmt SCOLON
    (38) statement -> . RETURN NAME SCOLON
    (28) cstatement -> . LFPAREN RFPAREN
    (29) cstatement -> . LFPAREN blockitemlist RFPAREN
    (52) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement ELSE statement
    (53) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement
    (54) iterationStmt -> . WHILE LPAREN expressionStmt RPAREN statement
    (55) iterationStmt -> . DO statement WHILE LPAREN expressionStmt RPAREN SCOLON
    (56) iterationStmt -> . FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement
    (6) varDeclaration -> . typeSpecifier NAME SCOLON
    (7) varDeclaration -> . typeSpecifier NAME EQUALS expressionStmt SCOLON
    (8) varDeclaration -> . typeSpecifier NAME EQUALS NUMBER
    (9) varDeclaration -> . typeSpecifier NAME EQUALS NAME
    (39) expressionStmt -> . NAME PLUS NAME
    (40) expressionStmt -> . NAME MINUS NAME
    (41) expressionStmt -> . NAME TIMES NAME
    (42) expressionStmt -> . NAME DIVIDES NAME
    (43) expressionStmt -> . NAME EQUALS NAME
    (44) expressionStmt -> . NAME GREATERTHAN NAME
    (45) expressionStmt -> . NAME LESSTHAN NAME
    (46) expressionStmt -> . NAME GREATEQ NAME
    (47) expressionStmt -> . NAME MODULUS NAME
    (48) expressionStmt -> . NAME LESSEQ NAME
    (49) expressionStmt -> . NAME EQUALS expressionStmt
    (50) expressionStmt -> . expressionStmt EQUALEQUAL NAME
    (51) expressionStmt -> . NAME
    (10) typeSpecifier -> . INT
    (11) typeSpecifier -> . BOOL
    (12) typeSpecifier -> . CHAR
    (13) typeSpecifier -> . FLOAT

    NAME            shift and go to state 64
    RETURN          shift and go to state 73
    LFPAREN         shift and go to state 65
    IF              shift and go to state 74
    WHILE           shift and go to state 75
    DO              shift and go to state 76
    FOR             shift and go to state 77
    INT             shift and go to state 28
    BOOL            shift and go to state 10
    CHAR            shift and go to state 11
    FLOAT           shift and go to state 29

    funcbody                       shift and go to state 80
    statement                      shift and go to state 67
    cstatement                     shift and go to state 68
    selectionStmt                  shift and go to state 69
    iterationStmt                  shift and go to state 70
    varDeclaration                 shift and go to state 71
    expressionStmt                 shift and go to state 72
    typeSpecifier                  shift and go to state 6

state 64

    (33) statement -> NAME . SCOLON
    (34) statement -> NAME . statement
    (39) expressionStmt -> NAME . PLUS NAME
    (40) expressionStmt -> NAME . MINUS NAME
    (41) expressionStmt -> NAME . TIMES NAME
    (42) expressionStmt -> NAME . DIVIDES NAME
    (43) expressionStmt -> NAME . EQUALS NAME
    (44) expressionStmt -> NAME . GREATERTHAN NAME
    (45) expressionStmt -> NAME . LESSTHAN NAME
    (46) expressionStmt -> NAME . GREATEQ NAME
    (47) expressionStmt -> NAME . MODULUS NAME
    (48) expressionStmt -> NAME . LESSEQ NAME
    (49) expressionStmt -> NAME . EQUALS expressionStmt
    (51) expressionStmt -> NAME .
    (30) statement -> . cstatement
    (31) statement -> . selectionStmt
    (32) statement -> . iterationStmt
    (33) statement -> . NAME SCOLON
    (34) statement -> . NAME statement
    (35) statement -> . varDeclaration statement
    (36) statement -> . expressionStmt SCOLON statement
    (37) statement -> . expressionStmt SCOLON
    (38) statement -> . RETURN NAME SCOLON
    (28) cstatement -> . LFPAREN RFPAREN
    (29) cstatement -> . LFPAREN blockitemlist RFPAREN
    (52) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement ELSE statement
    (53) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement
    (54) iterationStmt -> . WHILE LPAREN expressionStmt RPAREN statement
    (55) iterationStmt -> . DO statement WHILE LPAREN expressionStmt RPAREN SCOLON
    (56) iterationStmt -> . FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement
    (6) varDeclaration -> . typeSpecifier NAME SCOLON
    (7) varDeclaration -> . typeSpecifier NAME EQUALS expressionStmt SCOLON
    (8) varDeclaration -> . typeSpecifier NAME EQUALS NUMBER
    (9) varDeclaration -> . typeSpecifier NAME EQUALS NAME
    (39) expressionStmt -> . NAME PLUS NAME
    (40) expressionStmt -> . NAME MINUS NAME
    (41) expressionStmt -> . NAME TIMES NAME
    (42) expressionStmt -> . NAME DIVIDES NAME
    (43) expressionStmt -> . NAME EQUALS NAME
    (44) expressionStmt -> . NAME GREATERTHAN NAME
    (45) expressionStmt -> . NAME LESSTHAN NAME
    (46) expressionStmt -> . NAME GREATEQ NAME
    (47) expressionStmt -> . NAME MODULUS NAME
    (48) expressionStmt -> . NAME LESSEQ NAME
    (49) expressionStmt -> . NAME EQUALS expressionStmt
    (50) expressionStmt -> . expressionStmt EQUALEQUAL NAME
    (51) expressionStmt -> . NAME
    (10) typeSpecifier -> . INT
    (11) typeSpecifier -> . BOOL
    (12) typeSpecifier -> . CHAR
    (13) typeSpecifier -> . FLOAT

  ! shift/reduce conflict for SCOLON resolved as shift
    SCOLON          shift and go to state 81
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDES         shift and go to state 36
    EQUALS          shift and go to state 32
    GREATERTHAN     shift and go to state 37
    LESSTHAN        shift and go to state 38
    GREATEQ         shift and go to state 39
    MODULUS         shift and go to state 40
    LESSEQ          shift and go to state 41
    EQUALEQUAL      reduce using rule 51 (expressionStmt -> NAME .)
    NAME            shift and go to state 64
    RETURN          shift and go to state 73
    LFPAREN         shift and go to state 65
    IF              shift and go to state 74
    WHILE           shift and go to state 75
    DO              shift and go to state 76
    FOR             shift and go to state 77
    INT             shift and go to state 28
    BOOL            shift and go to state 10
    CHAR            shift and go to state 11
    FLOAT           shift and go to state 29

  ! SCOLON          [ reduce using rule 51 (expressionStmt -> NAME .) ]

    statement                      shift and go to state 82
    expressionStmt                 shift and go to state 72
    cstatement                     shift and go to state 68
    selectionStmt                  shift and go to state 69
    iterationStmt                  shift and go to state 70
    varDeclaration                 shift and go to state 71
    typeSpecifier                  shift and go to state 6

state 65

    (28) cstatement -> LFPAREN . RFPAREN
    (29) cstatement -> LFPAREN . blockitemlist RFPAREN
    (24) blockitemlist -> . blockitem
    (25) blockitemlist -> . blockitemlist blockitem
    (26) blockitem -> . statement
    (27) blockitem -> . varDeclaration
    (30) statement -> . cstatement
    (31) statement -> . selectionStmt
    (32) statement -> . iterationStmt
    (33) statement -> . NAME SCOLON
    (34) statement -> . NAME statement
    (35) statement -> . varDeclaration statement
    (36) statement -> . expressionStmt SCOLON statement
    (37) statement -> . expressionStmt SCOLON
    (38) statement -> . RETURN NAME SCOLON
    (6) varDeclaration -> . typeSpecifier NAME SCOLON
    (7) varDeclaration -> . typeSpecifier NAME EQUALS expressionStmt SCOLON
    (8) varDeclaration -> . typeSpecifier NAME EQUALS NUMBER
    (9) varDeclaration -> . typeSpecifier NAME EQUALS NAME
    (28) cstatement -> . LFPAREN RFPAREN
    (29) cstatement -> . LFPAREN blockitemlist RFPAREN
    (52) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement ELSE statement
    (53) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement
    (54) iterationStmt -> . WHILE LPAREN expressionStmt RPAREN statement
    (55) iterationStmt -> . DO statement WHILE LPAREN expressionStmt RPAREN SCOLON
    (56) iterationStmt -> . FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement
    (39) expressionStmt -> . NAME PLUS NAME
    (40) expressionStmt -> . NAME MINUS NAME
    (41) expressionStmt -> . NAME TIMES NAME
    (42) expressionStmt -> . NAME DIVIDES NAME
    (43) expressionStmt -> . NAME EQUALS NAME
    (44) expressionStmt -> . NAME GREATERTHAN NAME
    (45) expressionStmt -> . NAME LESSTHAN NAME
    (46) expressionStmt -> . NAME GREATEQ NAME
    (47) expressionStmt -> . NAME MODULUS NAME
    (48) expressionStmt -> . NAME LESSEQ NAME
    (49) expressionStmt -> . NAME EQUALS expressionStmt
    (50) expressionStmt -> . expressionStmt EQUALEQUAL NAME
    (51) expressionStmt -> . NAME
    (10) typeSpecifier -> . INT
    (11) typeSpecifier -> . BOOL
    (12) typeSpecifier -> . CHAR
    (13) typeSpecifier -> . FLOAT

    RFPAREN         shift and go to state 83
    NAME            shift and go to state 64
    RETURN          shift and go to state 73
    LFPAREN         shift and go to state 65
    IF              shift and go to state 74
    WHILE           shift and go to state 75
    DO              shift and go to state 76
    FOR             shift and go to state 77
    INT             shift and go to state 28
    BOOL            shift and go to state 10
    CHAR            shift and go to state 11
    FLOAT           shift and go to state 29

    blockitemlist                  shift and go to state 84
    blockitem                      shift and go to state 85
    statement                      shift and go to state 86
    varDeclaration                 shift and go to state 87
    cstatement                     shift and go to state 68
    selectionStmt                  shift and go to state 69
    iterationStmt                  shift and go to state 70
    expressionStmt                 shift and go to state 72
    typeSpecifier                  shift and go to state 6

state 66

    (14) funcdef -> VOID NAME LPAREN parameters RPAREN LFPAREN funcbody . RFPAREN

    RFPAREN         shift and go to state 88


state 67

    (21) funcbody -> statement .
    (22) funcbody -> statement . funcbody
    (23) funcbody -> statement . SCOLON funcbody
    (21) funcbody -> . statement
    (22) funcbody -> . statement funcbody
    (23) funcbody -> . statement SCOLON funcbody
    (30) statement -> . cstatement
    (31) statement -> . selectionStmt
    (32) statement -> . iterationStmt
    (33) statement -> . NAME SCOLON
    (34) statement -> . NAME statement
    (35) statement -> . varDeclaration statement
    (36) statement -> . expressionStmt SCOLON statement
    (37) statement -> . expressionStmt SCOLON
    (38) statement -> . RETURN NAME SCOLON
    (28) cstatement -> . LFPAREN RFPAREN
    (29) cstatement -> . LFPAREN blockitemlist RFPAREN
    (52) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement ELSE statement
    (53) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement
    (54) iterationStmt -> . WHILE LPAREN expressionStmt RPAREN statement
    (55) iterationStmt -> . DO statement WHILE LPAREN expressionStmt RPAREN SCOLON
    (56) iterationStmt -> . FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement
    (6) varDeclaration -> . typeSpecifier NAME SCOLON
    (7) varDeclaration -> . typeSpecifier NAME EQUALS expressionStmt SCOLON
    (8) varDeclaration -> . typeSpecifier NAME EQUALS NUMBER
    (9) varDeclaration -> . typeSpecifier NAME EQUALS NAME
    (39) expressionStmt -> . NAME PLUS NAME
    (40) expressionStmt -> . NAME MINUS NAME
    (41) expressionStmt -> . NAME TIMES NAME
    (42) expressionStmt -> . NAME DIVIDES NAME
    (43) expressionStmt -> . NAME EQUALS NAME
    (44) expressionStmt -> . NAME GREATERTHAN NAME
    (45) expressionStmt -> . NAME LESSTHAN NAME
    (46) expressionStmt -> . NAME GREATEQ NAME
    (47) expressionStmt -> . NAME MODULUS NAME
    (48) expressionStmt -> . NAME LESSEQ NAME
    (49) expressionStmt -> . NAME EQUALS expressionStmt
    (50) expressionStmt -> . expressionStmt EQUALEQUAL NAME
    (51) expressionStmt -> . NAME
    (10) typeSpecifier -> . INT
    (11) typeSpecifier -> . BOOL
    (12) typeSpecifier -> . CHAR
    (13) typeSpecifier -> . FLOAT

    RFPAREN         reduce using rule 21 (funcbody -> statement .)
    SCOLON          shift and go to state 90
    NAME            shift and go to state 64
    RETURN          shift and go to state 73
    LFPAREN         shift and go to state 65
    IF              shift and go to state 74
    WHILE           shift and go to state 75
    DO              shift and go to state 76
    FOR             shift and go to state 77
    INT             shift and go to state 28
    BOOL            shift and go to state 10
    CHAR            shift and go to state 11
    FLOAT           shift and go to state 29

    statement                      shift and go to state 67
    funcbody                       shift and go to state 89
    cstatement                     shift and go to state 68
    selectionStmt                  shift and go to state 69
    iterationStmt                  shift and go to state 70
    varDeclaration                 shift and go to state 71
    expressionStmt                 shift and go to state 72
    typeSpecifier                  shift and go to state 6

state 68

    (30) statement -> cstatement .

    SCOLON          reduce using rule 30 (statement -> cstatement .)
    NAME            reduce using rule 30 (statement -> cstatement .)
    RETURN          reduce using rule 30 (statement -> cstatement .)
    LFPAREN         reduce using rule 30 (statement -> cstatement .)
    IF              reduce using rule 30 (statement -> cstatement .)
    WHILE           reduce using rule 30 (statement -> cstatement .)
    DO              reduce using rule 30 (statement -> cstatement .)
    FOR             reduce using rule 30 (statement -> cstatement .)
    INT             reduce using rule 30 (statement -> cstatement .)
    BOOL            reduce using rule 30 (statement -> cstatement .)
    CHAR            reduce using rule 30 (statement -> cstatement .)
    FLOAT           reduce using rule 30 (statement -> cstatement .)
    RFPAREN         reduce using rule 30 (statement -> cstatement .)
    ELSE            reduce using rule 30 (statement -> cstatement .)


state 69

    (31) statement -> selectionStmt .

    SCOLON          reduce using rule 31 (statement -> selectionStmt .)
    NAME            reduce using rule 31 (statement -> selectionStmt .)
    RETURN          reduce using rule 31 (statement -> selectionStmt .)
    LFPAREN         reduce using rule 31 (statement -> selectionStmt .)
    IF              reduce using rule 31 (statement -> selectionStmt .)
    WHILE           reduce using rule 31 (statement -> selectionStmt .)
    DO              reduce using rule 31 (statement -> selectionStmt .)
    FOR             reduce using rule 31 (statement -> selectionStmt .)
    INT             reduce using rule 31 (statement -> selectionStmt .)
    BOOL            reduce using rule 31 (statement -> selectionStmt .)
    CHAR            reduce using rule 31 (statement -> selectionStmt .)
    FLOAT           reduce using rule 31 (statement -> selectionStmt .)
    RFPAREN         reduce using rule 31 (statement -> selectionStmt .)
    ELSE            reduce using rule 31 (statement -> selectionStmt .)


state 70

    (32) statement -> iterationStmt .

    SCOLON          reduce using rule 32 (statement -> iterationStmt .)
    NAME            reduce using rule 32 (statement -> iterationStmt .)
    RETURN          reduce using rule 32 (statement -> iterationStmt .)
    LFPAREN         reduce using rule 32 (statement -> iterationStmt .)
    IF              reduce using rule 32 (statement -> iterationStmt .)
    WHILE           reduce using rule 32 (statement -> iterationStmt .)
    DO              reduce using rule 32 (statement -> iterationStmt .)
    FOR             reduce using rule 32 (statement -> iterationStmt .)
    INT             reduce using rule 32 (statement -> iterationStmt .)
    BOOL            reduce using rule 32 (statement -> iterationStmt .)
    CHAR            reduce using rule 32 (statement -> iterationStmt .)
    FLOAT           reduce using rule 32 (statement -> iterationStmt .)
    RFPAREN         reduce using rule 32 (statement -> iterationStmt .)
    ELSE            reduce using rule 32 (statement -> iterationStmt .)


state 71

    (35) statement -> varDeclaration . statement
    (30) statement -> . cstatement
    (31) statement -> . selectionStmt
    (32) statement -> . iterationStmt
    (33) statement -> . NAME SCOLON
    (34) statement -> . NAME statement
    (35) statement -> . varDeclaration statement
    (36) statement -> . expressionStmt SCOLON statement
    (37) statement -> . expressionStmt SCOLON
    (38) statement -> . RETURN NAME SCOLON
    (28) cstatement -> . LFPAREN RFPAREN
    (29) cstatement -> . LFPAREN blockitemlist RFPAREN
    (52) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement ELSE statement
    (53) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement
    (54) iterationStmt -> . WHILE LPAREN expressionStmt RPAREN statement
    (55) iterationStmt -> . DO statement WHILE LPAREN expressionStmt RPAREN SCOLON
    (56) iterationStmt -> . FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement
    (6) varDeclaration -> . typeSpecifier NAME SCOLON
    (7) varDeclaration -> . typeSpecifier NAME EQUALS expressionStmt SCOLON
    (8) varDeclaration -> . typeSpecifier NAME EQUALS NUMBER
    (9) varDeclaration -> . typeSpecifier NAME EQUALS NAME
    (39) expressionStmt -> . NAME PLUS NAME
    (40) expressionStmt -> . NAME MINUS NAME
    (41) expressionStmt -> . NAME TIMES NAME
    (42) expressionStmt -> . NAME DIVIDES NAME
    (43) expressionStmt -> . NAME EQUALS NAME
    (44) expressionStmt -> . NAME GREATERTHAN NAME
    (45) expressionStmt -> . NAME LESSTHAN NAME
    (46) expressionStmt -> . NAME GREATEQ NAME
    (47) expressionStmt -> . NAME MODULUS NAME
    (48) expressionStmt -> . NAME LESSEQ NAME
    (49) expressionStmt -> . NAME EQUALS expressionStmt
    (50) expressionStmt -> . expressionStmt EQUALEQUAL NAME
    (51) expressionStmt -> . NAME
    (10) typeSpecifier -> . INT
    (11) typeSpecifier -> . BOOL
    (12) typeSpecifier -> . CHAR
    (13) typeSpecifier -> . FLOAT

    NAME            shift and go to state 64
    RETURN          shift and go to state 73
    LFPAREN         shift and go to state 65
    IF              shift and go to state 74
    WHILE           shift and go to state 75
    DO              shift and go to state 76
    FOR             shift and go to state 77
    INT             shift and go to state 28
    BOOL            shift and go to state 10
    CHAR            shift and go to state 11
    FLOAT           shift and go to state 29

    varDeclaration                 shift and go to state 71
    statement                      shift and go to state 91
    cstatement                     shift and go to state 68
    selectionStmt                  shift and go to state 69
    iterationStmt                  shift and go to state 70
    expressionStmt                 shift and go to state 72
    typeSpecifier                  shift and go to state 6

state 72

    (36) statement -> expressionStmt . SCOLON statement
    (37) statement -> expressionStmt . SCOLON
    (50) expressionStmt -> expressionStmt . EQUALEQUAL NAME

    SCOLON          shift and go to state 92
    EQUALEQUAL      shift and go to state 43


state 73

    (38) statement -> RETURN . NAME SCOLON

    NAME            shift and go to state 93


state 74

    (52) selectionStmt -> IF . LPAREN expressionStmt RPAREN statement ELSE statement
    (53) selectionStmt -> IF . LPAREN expressionStmt RPAREN statement

    LPAREN          shift and go to state 94


state 75

    (54) iterationStmt -> WHILE . LPAREN expressionStmt RPAREN statement

    LPAREN          shift and go to state 95


state 76

    (55) iterationStmt -> DO . statement WHILE LPAREN expressionStmt RPAREN SCOLON
    (30) statement -> . cstatement
    (31) statement -> . selectionStmt
    (32) statement -> . iterationStmt
    (33) statement -> . NAME SCOLON
    (34) statement -> . NAME statement
    (35) statement -> . varDeclaration statement
    (36) statement -> . expressionStmt SCOLON statement
    (37) statement -> . expressionStmt SCOLON
    (38) statement -> . RETURN NAME SCOLON
    (28) cstatement -> . LFPAREN RFPAREN
    (29) cstatement -> . LFPAREN blockitemlist RFPAREN
    (52) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement ELSE statement
    (53) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement
    (54) iterationStmt -> . WHILE LPAREN expressionStmt RPAREN statement
    (55) iterationStmt -> . DO statement WHILE LPAREN expressionStmt RPAREN SCOLON
    (56) iterationStmt -> . FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement
    (6) varDeclaration -> . typeSpecifier NAME SCOLON
    (7) varDeclaration -> . typeSpecifier NAME EQUALS expressionStmt SCOLON
    (8) varDeclaration -> . typeSpecifier NAME EQUALS NUMBER
    (9) varDeclaration -> . typeSpecifier NAME EQUALS NAME
    (39) expressionStmt -> . NAME PLUS NAME
    (40) expressionStmt -> . NAME MINUS NAME
    (41) expressionStmt -> . NAME TIMES NAME
    (42) expressionStmt -> . NAME DIVIDES NAME
    (43) expressionStmt -> . NAME EQUALS NAME
    (44) expressionStmt -> . NAME GREATERTHAN NAME
    (45) expressionStmt -> . NAME LESSTHAN NAME
    (46) expressionStmt -> . NAME GREATEQ NAME
    (47) expressionStmt -> . NAME MODULUS NAME
    (48) expressionStmt -> . NAME LESSEQ NAME
    (49) expressionStmt -> . NAME EQUALS expressionStmt
    (50) expressionStmt -> . expressionStmt EQUALEQUAL NAME
    (51) expressionStmt -> . NAME
    (10) typeSpecifier -> . INT
    (11) typeSpecifier -> . BOOL
    (12) typeSpecifier -> . CHAR
    (13) typeSpecifier -> . FLOAT

    NAME            shift and go to state 64
    RETURN          shift and go to state 73
    LFPAREN         shift and go to state 65
    IF              shift and go to state 74
    WHILE           shift and go to state 75
    DO              shift and go to state 76
    FOR             shift and go to state 77
    INT             shift and go to state 28
    BOOL            shift and go to state 10
    CHAR            shift and go to state 11
    FLOAT           shift and go to state 29

    statement                      shift and go to state 96
    expressionStmt                 shift and go to state 72
    cstatement                     shift and go to state 68
    selectionStmt                  shift and go to state 69
    iterationStmt                  shift and go to state 70
    varDeclaration                 shift and go to state 71
    typeSpecifier                  shift and go to state 6

state 77

    (56) iterationStmt -> FOR . LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement

    LPAREN          shift and go to state 97


state 78

    (19) parameters -> typeSpecifier NAME COMMA parameters .

    RPAREN          reduce using rule 19 (parameters -> typeSpecifier NAME COMMA parameters .)


state 79

    (15) funcdef -> INT NAME LPAREN parameters RPAREN LFPAREN funcbody . RFPAREN

    RFPAREN         shift and go to state 98


state 80

    (17) funcdef -> FLOAT NAME LPAREN parameters RPAREN LFPAREN funcbody . RFPAREN

    RFPAREN         shift and go to state 99


state 81

    (33) statement -> NAME SCOLON .

    SCOLON          reduce using rule 33 (statement -> NAME SCOLON .)
    NAME            reduce using rule 33 (statement -> NAME SCOLON .)
    RETURN          reduce using rule 33 (statement -> NAME SCOLON .)
    LFPAREN         reduce using rule 33 (statement -> NAME SCOLON .)
    IF              reduce using rule 33 (statement -> NAME SCOLON .)
    WHILE           reduce using rule 33 (statement -> NAME SCOLON .)
    DO              reduce using rule 33 (statement -> NAME SCOLON .)
    FOR             reduce using rule 33 (statement -> NAME SCOLON .)
    INT             reduce using rule 33 (statement -> NAME SCOLON .)
    BOOL            reduce using rule 33 (statement -> NAME SCOLON .)
    CHAR            reduce using rule 33 (statement -> NAME SCOLON .)
    FLOAT           reduce using rule 33 (statement -> NAME SCOLON .)
    RFPAREN         reduce using rule 33 (statement -> NAME SCOLON .)
    ELSE            reduce using rule 33 (statement -> NAME SCOLON .)


state 82

    (34) statement -> NAME statement .

    SCOLON          reduce using rule 34 (statement -> NAME statement .)
    NAME            reduce using rule 34 (statement -> NAME statement .)
    RETURN          reduce using rule 34 (statement -> NAME statement .)
    LFPAREN         reduce using rule 34 (statement -> NAME statement .)
    IF              reduce using rule 34 (statement -> NAME statement .)
    WHILE           reduce using rule 34 (statement -> NAME statement .)
    DO              reduce using rule 34 (statement -> NAME statement .)
    FOR             reduce using rule 34 (statement -> NAME statement .)
    INT             reduce using rule 34 (statement -> NAME statement .)
    BOOL            reduce using rule 34 (statement -> NAME statement .)
    CHAR            reduce using rule 34 (statement -> NAME statement .)
    FLOAT           reduce using rule 34 (statement -> NAME statement .)
    RFPAREN         reduce using rule 34 (statement -> NAME statement .)
    ELSE            reduce using rule 34 (statement -> NAME statement .)


state 83

    (28) cstatement -> LFPAREN RFPAREN .

    SCOLON          reduce using rule 28 (cstatement -> LFPAREN RFPAREN .)
    NAME            reduce using rule 28 (cstatement -> LFPAREN RFPAREN .)
    RETURN          reduce using rule 28 (cstatement -> LFPAREN RFPAREN .)
    LFPAREN         reduce using rule 28 (cstatement -> LFPAREN RFPAREN .)
    IF              reduce using rule 28 (cstatement -> LFPAREN RFPAREN .)
    WHILE           reduce using rule 28 (cstatement -> LFPAREN RFPAREN .)
    DO              reduce using rule 28 (cstatement -> LFPAREN RFPAREN .)
    FOR             reduce using rule 28 (cstatement -> LFPAREN RFPAREN .)
    INT             reduce using rule 28 (cstatement -> LFPAREN RFPAREN .)
    BOOL            reduce using rule 28 (cstatement -> LFPAREN RFPAREN .)
    CHAR            reduce using rule 28 (cstatement -> LFPAREN RFPAREN .)
    FLOAT           reduce using rule 28 (cstatement -> LFPAREN RFPAREN .)
    RFPAREN         reduce using rule 28 (cstatement -> LFPAREN RFPAREN .)
    ELSE            reduce using rule 28 (cstatement -> LFPAREN RFPAREN .)


state 84

    (29) cstatement -> LFPAREN blockitemlist . RFPAREN
    (25) blockitemlist -> blockitemlist . blockitem
    (26) blockitem -> . statement
    (27) blockitem -> . varDeclaration
    (30) statement -> . cstatement
    (31) statement -> . selectionStmt
    (32) statement -> . iterationStmt
    (33) statement -> . NAME SCOLON
    (34) statement -> . NAME statement
    (35) statement -> . varDeclaration statement
    (36) statement -> . expressionStmt SCOLON statement
    (37) statement -> . expressionStmt SCOLON
    (38) statement -> . RETURN NAME SCOLON
    (6) varDeclaration -> . typeSpecifier NAME SCOLON
    (7) varDeclaration -> . typeSpecifier NAME EQUALS expressionStmt SCOLON
    (8) varDeclaration -> . typeSpecifier NAME EQUALS NUMBER
    (9) varDeclaration -> . typeSpecifier NAME EQUALS NAME
    (28) cstatement -> . LFPAREN RFPAREN
    (29) cstatement -> . LFPAREN blockitemlist RFPAREN
    (52) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement ELSE statement
    (53) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement
    (54) iterationStmt -> . WHILE LPAREN expressionStmt RPAREN statement
    (55) iterationStmt -> . DO statement WHILE LPAREN expressionStmt RPAREN SCOLON
    (56) iterationStmt -> . FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement
    (39) expressionStmt -> . NAME PLUS NAME
    (40) expressionStmt -> . NAME MINUS NAME
    (41) expressionStmt -> . NAME TIMES NAME
    (42) expressionStmt -> . NAME DIVIDES NAME
    (43) expressionStmt -> . NAME EQUALS NAME
    (44) expressionStmt -> . NAME GREATERTHAN NAME
    (45) expressionStmt -> . NAME LESSTHAN NAME
    (46) expressionStmt -> . NAME GREATEQ NAME
    (47) expressionStmt -> . NAME MODULUS NAME
    (48) expressionStmt -> . NAME LESSEQ NAME
    (49) expressionStmt -> . NAME EQUALS expressionStmt
    (50) expressionStmt -> . expressionStmt EQUALEQUAL NAME
    (51) expressionStmt -> . NAME
    (10) typeSpecifier -> . INT
    (11) typeSpecifier -> . BOOL
    (12) typeSpecifier -> . CHAR
    (13) typeSpecifier -> . FLOAT

    RFPAREN         shift and go to state 100
    NAME            shift and go to state 64
    RETURN          shift and go to state 73
    LFPAREN         shift and go to state 65
    IF              shift and go to state 74
    WHILE           shift and go to state 75
    DO              shift and go to state 76
    FOR             shift and go to state 77
    INT             shift and go to state 28
    BOOL            shift and go to state 10
    CHAR            shift and go to state 11
    FLOAT           shift and go to state 29

    blockitem                      shift and go to state 101
    statement                      shift and go to state 86
    varDeclaration                 shift and go to state 87
    cstatement                     shift and go to state 68
    selectionStmt                  shift and go to state 69
    iterationStmt                  shift and go to state 70
    expressionStmt                 shift and go to state 72
    typeSpecifier                  shift and go to state 6

state 85

    (24) blockitemlist -> blockitem .

    RFPAREN         reduce using rule 24 (blockitemlist -> blockitem .)
    NAME            reduce using rule 24 (blockitemlist -> blockitem .)
    RETURN          reduce using rule 24 (blockitemlist -> blockitem .)
    LFPAREN         reduce using rule 24 (blockitemlist -> blockitem .)
    IF              reduce using rule 24 (blockitemlist -> blockitem .)
    WHILE           reduce using rule 24 (blockitemlist -> blockitem .)
    DO              reduce using rule 24 (blockitemlist -> blockitem .)
    FOR             reduce using rule 24 (blockitemlist -> blockitem .)
    INT             reduce using rule 24 (blockitemlist -> blockitem .)
    BOOL            reduce using rule 24 (blockitemlist -> blockitem .)
    CHAR            reduce using rule 24 (blockitemlist -> blockitem .)
    FLOAT           reduce using rule 24 (blockitemlist -> blockitem .)


state 86

    (26) blockitem -> statement .

    RFPAREN         reduce using rule 26 (blockitem -> statement .)
    NAME            reduce using rule 26 (blockitem -> statement .)
    RETURN          reduce using rule 26 (blockitem -> statement .)
    LFPAREN         reduce using rule 26 (blockitem -> statement .)
    IF              reduce using rule 26 (blockitem -> statement .)
    WHILE           reduce using rule 26 (blockitem -> statement .)
    DO              reduce using rule 26 (blockitem -> statement .)
    FOR             reduce using rule 26 (blockitem -> statement .)
    INT             reduce using rule 26 (blockitem -> statement .)
    BOOL            reduce using rule 26 (blockitem -> statement .)
    CHAR            reduce using rule 26 (blockitem -> statement .)
    FLOAT           reduce using rule 26 (blockitem -> statement .)


state 87

    (27) blockitem -> varDeclaration .
    (35) statement -> varDeclaration . statement
    (30) statement -> . cstatement
    (31) statement -> . selectionStmt
    (32) statement -> . iterationStmt
    (33) statement -> . NAME SCOLON
    (34) statement -> . NAME statement
    (35) statement -> . varDeclaration statement
    (36) statement -> . expressionStmt SCOLON statement
    (37) statement -> . expressionStmt SCOLON
    (38) statement -> . RETURN NAME SCOLON
    (28) cstatement -> . LFPAREN RFPAREN
    (29) cstatement -> . LFPAREN blockitemlist RFPAREN
    (52) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement ELSE statement
    (53) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement
    (54) iterationStmt -> . WHILE LPAREN expressionStmt RPAREN statement
    (55) iterationStmt -> . DO statement WHILE LPAREN expressionStmt RPAREN SCOLON
    (56) iterationStmt -> . FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement
    (6) varDeclaration -> . typeSpecifier NAME SCOLON
    (7) varDeclaration -> . typeSpecifier NAME EQUALS expressionStmt SCOLON
    (8) varDeclaration -> . typeSpecifier NAME EQUALS NUMBER
    (9) varDeclaration -> . typeSpecifier NAME EQUALS NAME
    (39) expressionStmt -> . NAME PLUS NAME
    (40) expressionStmt -> . NAME MINUS NAME
    (41) expressionStmt -> . NAME TIMES NAME
    (42) expressionStmt -> . NAME DIVIDES NAME
    (43) expressionStmt -> . NAME EQUALS NAME
    (44) expressionStmt -> . NAME GREATERTHAN NAME
    (45) expressionStmt -> . NAME LESSTHAN NAME
    (46) expressionStmt -> . NAME GREATEQ NAME
    (47) expressionStmt -> . NAME MODULUS NAME
    (48) expressionStmt -> . NAME LESSEQ NAME
    (49) expressionStmt -> . NAME EQUALS expressionStmt
    (50) expressionStmt -> . expressionStmt EQUALEQUAL NAME
    (51) expressionStmt -> . NAME
    (10) typeSpecifier -> . INT
    (11) typeSpecifier -> . BOOL
    (12) typeSpecifier -> . CHAR
    (13) typeSpecifier -> . FLOAT

  ! shift/reduce conflict for NAME resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for LFPAREN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for DO resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    RFPAREN         reduce using rule 27 (blockitem -> varDeclaration .)
    NAME            shift and go to state 64
    RETURN          shift and go to state 73
    LFPAREN         shift and go to state 65
    IF              shift and go to state 74
    WHILE           shift and go to state 75
    DO              shift and go to state 76
    FOR             shift and go to state 77
    INT             shift and go to state 28
    BOOL            shift and go to state 10
    CHAR            shift and go to state 11
    FLOAT           shift and go to state 29

  ! NAME            [ reduce using rule 27 (blockitem -> varDeclaration .) ]
  ! RETURN          [ reduce using rule 27 (blockitem -> varDeclaration .) ]
  ! LFPAREN         [ reduce using rule 27 (blockitem -> varDeclaration .) ]
  ! IF              [ reduce using rule 27 (blockitem -> varDeclaration .) ]
  ! WHILE           [ reduce using rule 27 (blockitem -> varDeclaration .) ]
  ! DO              [ reduce using rule 27 (blockitem -> varDeclaration .) ]
  ! FOR             [ reduce using rule 27 (blockitem -> varDeclaration .) ]
  ! INT             [ reduce using rule 27 (blockitem -> varDeclaration .) ]
  ! BOOL            [ reduce using rule 27 (blockitem -> varDeclaration .) ]
  ! CHAR            [ reduce using rule 27 (blockitem -> varDeclaration .) ]
  ! FLOAT           [ reduce using rule 27 (blockitem -> varDeclaration .) ]

    varDeclaration                 shift and go to state 71
    statement                      shift and go to state 91
    cstatement                     shift and go to state 68
    selectionStmt                  shift and go to state 69
    iterationStmt                  shift and go to state 70
    expressionStmt                 shift and go to state 72
    typeSpecifier                  shift and go to state 6

state 88

    (14) funcdef -> VOID NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN .

    VOID            reduce using rule 14 (funcdef -> VOID NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN .)
    INT             reduce using rule 14 (funcdef -> VOID NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN .)
    FLOAT           reduce using rule 14 (funcdef -> VOID NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN .)
    BOOL            reduce using rule 14 (funcdef -> VOID NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN .)
    CHAR            reduce using rule 14 (funcdef -> VOID NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN .)
    $end            reduce using rule 14 (funcdef -> VOID NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN .)


state 89

    (22) funcbody -> statement funcbody .

    RFPAREN         reduce using rule 22 (funcbody -> statement funcbody .)


state 90

    (23) funcbody -> statement SCOLON . funcbody
    (21) funcbody -> . statement
    (22) funcbody -> . statement funcbody
    (23) funcbody -> . statement SCOLON funcbody
    (30) statement -> . cstatement
    (31) statement -> . selectionStmt
    (32) statement -> . iterationStmt
    (33) statement -> . NAME SCOLON
    (34) statement -> . NAME statement
    (35) statement -> . varDeclaration statement
    (36) statement -> . expressionStmt SCOLON statement
    (37) statement -> . expressionStmt SCOLON
    (38) statement -> . RETURN NAME SCOLON
    (28) cstatement -> . LFPAREN RFPAREN
    (29) cstatement -> . LFPAREN blockitemlist RFPAREN
    (52) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement ELSE statement
    (53) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement
    (54) iterationStmt -> . WHILE LPAREN expressionStmt RPAREN statement
    (55) iterationStmt -> . DO statement WHILE LPAREN expressionStmt RPAREN SCOLON
    (56) iterationStmt -> . FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement
    (6) varDeclaration -> . typeSpecifier NAME SCOLON
    (7) varDeclaration -> . typeSpecifier NAME EQUALS expressionStmt SCOLON
    (8) varDeclaration -> . typeSpecifier NAME EQUALS NUMBER
    (9) varDeclaration -> . typeSpecifier NAME EQUALS NAME
    (39) expressionStmt -> . NAME PLUS NAME
    (40) expressionStmt -> . NAME MINUS NAME
    (41) expressionStmt -> . NAME TIMES NAME
    (42) expressionStmt -> . NAME DIVIDES NAME
    (43) expressionStmt -> . NAME EQUALS NAME
    (44) expressionStmt -> . NAME GREATERTHAN NAME
    (45) expressionStmt -> . NAME LESSTHAN NAME
    (46) expressionStmt -> . NAME GREATEQ NAME
    (47) expressionStmt -> . NAME MODULUS NAME
    (48) expressionStmt -> . NAME LESSEQ NAME
    (49) expressionStmt -> . NAME EQUALS expressionStmt
    (50) expressionStmt -> . expressionStmt EQUALEQUAL NAME
    (51) expressionStmt -> . NAME
    (10) typeSpecifier -> . INT
    (11) typeSpecifier -> . BOOL
    (12) typeSpecifier -> . CHAR
    (13) typeSpecifier -> . FLOAT

    NAME            shift and go to state 64
    RETURN          shift and go to state 73
    LFPAREN         shift and go to state 65
    IF              shift and go to state 74
    WHILE           shift and go to state 75
    DO              shift and go to state 76
    FOR             shift and go to state 77
    INT             shift and go to state 28
    BOOL            shift and go to state 10
    CHAR            shift and go to state 11
    FLOAT           shift and go to state 29

    statement                      shift and go to state 67
    funcbody                       shift and go to state 102
    cstatement                     shift and go to state 68
    selectionStmt                  shift and go to state 69
    iterationStmt                  shift and go to state 70
    varDeclaration                 shift and go to state 71
    expressionStmt                 shift and go to state 72
    typeSpecifier                  shift and go to state 6

state 91

    (35) statement -> varDeclaration statement .

    SCOLON          reduce using rule 35 (statement -> varDeclaration statement .)
    NAME            reduce using rule 35 (statement -> varDeclaration statement .)
    RETURN          reduce using rule 35 (statement -> varDeclaration statement .)
    LFPAREN         reduce using rule 35 (statement -> varDeclaration statement .)
    IF              reduce using rule 35 (statement -> varDeclaration statement .)
    WHILE           reduce using rule 35 (statement -> varDeclaration statement .)
    DO              reduce using rule 35 (statement -> varDeclaration statement .)
    FOR             reduce using rule 35 (statement -> varDeclaration statement .)
    INT             reduce using rule 35 (statement -> varDeclaration statement .)
    BOOL            reduce using rule 35 (statement -> varDeclaration statement .)
    CHAR            reduce using rule 35 (statement -> varDeclaration statement .)
    FLOAT           reduce using rule 35 (statement -> varDeclaration statement .)
    RFPAREN         reduce using rule 35 (statement -> varDeclaration statement .)
    ELSE            reduce using rule 35 (statement -> varDeclaration statement .)


state 92

    (36) statement -> expressionStmt SCOLON . statement
    (37) statement -> expressionStmt SCOLON .
    (30) statement -> . cstatement
    (31) statement -> . selectionStmt
    (32) statement -> . iterationStmt
    (33) statement -> . NAME SCOLON
    (34) statement -> . NAME statement
    (35) statement -> . varDeclaration statement
    (36) statement -> . expressionStmt SCOLON statement
    (37) statement -> . expressionStmt SCOLON
    (38) statement -> . RETURN NAME SCOLON
    (28) cstatement -> . LFPAREN RFPAREN
    (29) cstatement -> . LFPAREN blockitemlist RFPAREN
    (52) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement ELSE statement
    (53) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement
    (54) iterationStmt -> . WHILE LPAREN expressionStmt RPAREN statement
    (55) iterationStmt -> . DO statement WHILE LPAREN expressionStmt RPAREN SCOLON
    (56) iterationStmt -> . FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement
    (6) varDeclaration -> . typeSpecifier NAME SCOLON
    (7) varDeclaration -> . typeSpecifier NAME EQUALS expressionStmt SCOLON
    (8) varDeclaration -> . typeSpecifier NAME EQUALS NUMBER
    (9) varDeclaration -> . typeSpecifier NAME EQUALS NAME
    (39) expressionStmt -> . NAME PLUS NAME
    (40) expressionStmt -> . NAME MINUS NAME
    (41) expressionStmt -> . NAME TIMES NAME
    (42) expressionStmt -> . NAME DIVIDES NAME
    (43) expressionStmt -> . NAME EQUALS NAME
    (44) expressionStmt -> . NAME GREATERTHAN NAME
    (45) expressionStmt -> . NAME LESSTHAN NAME
    (46) expressionStmt -> . NAME GREATEQ NAME
    (47) expressionStmt -> . NAME MODULUS NAME
    (48) expressionStmt -> . NAME LESSEQ NAME
    (49) expressionStmt -> . NAME EQUALS expressionStmt
    (50) expressionStmt -> . expressionStmt EQUALEQUAL NAME
    (51) expressionStmt -> . NAME
    (10) typeSpecifier -> . INT
    (11) typeSpecifier -> . BOOL
    (12) typeSpecifier -> . CHAR
    (13) typeSpecifier -> . FLOAT

  ! shift/reduce conflict for NAME resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for LFPAREN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for DO resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    SCOLON          reduce using rule 37 (statement -> expressionStmt SCOLON .)
    RFPAREN         reduce using rule 37 (statement -> expressionStmt SCOLON .)
    ELSE            reduce using rule 37 (statement -> expressionStmt SCOLON .)
    NAME            shift and go to state 64
    RETURN          shift and go to state 73
    LFPAREN         shift and go to state 65
    IF              shift and go to state 74
    WHILE           shift and go to state 75
    DO              shift and go to state 76
    FOR             shift and go to state 77
    INT             shift and go to state 28
    BOOL            shift and go to state 10
    CHAR            shift and go to state 11
    FLOAT           shift and go to state 29

  ! NAME            [ reduce using rule 37 (statement -> expressionStmt SCOLON .) ]
  ! RETURN          [ reduce using rule 37 (statement -> expressionStmt SCOLON .) ]
  ! LFPAREN         [ reduce using rule 37 (statement -> expressionStmt SCOLON .) ]
  ! IF              [ reduce using rule 37 (statement -> expressionStmt SCOLON .) ]
  ! WHILE           [ reduce using rule 37 (statement -> expressionStmt SCOLON .) ]
  ! DO              [ reduce using rule 37 (statement -> expressionStmt SCOLON .) ]
  ! FOR             [ reduce using rule 37 (statement -> expressionStmt SCOLON .) ]
  ! INT             [ reduce using rule 37 (statement -> expressionStmt SCOLON .) ]
  ! BOOL            [ reduce using rule 37 (statement -> expressionStmt SCOLON .) ]
  ! CHAR            [ reduce using rule 37 (statement -> expressionStmt SCOLON .) ]
  ! FLOAT           [ reduce using rule 37 (statement -> expressionStmt SCOLON .) ]

    expressionStmt                 shift and go to state 72
    statement                      shift and go to state 103
    cstatement                     shift and go to state 68
    selectionStmt                  shift and go to state 69
    iterationStmt                  shift and go to state 70
    varDeclaration                 shift and go to state 71
    typeSpecifier                  shift and go to state 6

state 93

    (38) statement -> RETURN NAME . SCOLON

    SCOLON          shift and go to state 104


state 94

    (52) selectionStmt -> IF LPAREN . expressionStmt RPAREN statement ELSE statement
    (53) selectionStmt -> IF LPAREN . expressionStmt RPAREN statement
    (39) expressionStmt -> . NAME PLUS NAME
    (40) expressionStmt -> . NAME MINUS NAME
    (41) expressionStmt -> . NAME TIMES NAME
    (42) expressionStmt -> . NAME DIVIDES NAME
    (43) expressionStmt -> . NAME EQUALS NAME
    (44) expressionStmt -> . NAME GREATERTHAN NAME
    (45) expressionStmt -> . NAME LESSTHAN NAME
    (46) expressionStmt -> . NAME GREATEQ NAME
    (47) expressionStmt -> . NAME MODULUS NAME
    (48) expressionStmt -> . NAME LESSEQ NAME
    (49) expressionStmt -> . NAME EQUALS expressionStmt
    (50) expressionStmt -> . expressionStmt EQUALEQUAL NAME
    (51) expressionStmt -> . NAME

    NAME            shift and go to state 106

    expressionStmt                 shift and go to state 105

state 95

    (54) iterationStmt -> WHILE LPAREN . expressionStmt RPAREN statement
    (39) expressionStmt -> . NAME PLUS NAME
    (40) expressionStmt -> . NAME MINUS NAME
    (41) expressionStmt -> . NAME TIMES NAME
    (42) expressionStmt -> . NAME DIVIDES NAME
    (43) expressionStmt -> . NAME EQUALS NAME
    (44) expressionStmt -> . NAME GREATERTHAN NAME
    (45) expressionStmt -> . NAME LESSTHAN NAME
    (46) expressionStmt -> . NAME GREATEQ NAME
    (47) expressionStmt -> . NAME MODULUS NAME
    (48) expressionStmt -> . NAME LESSEQ NAME
    (49) expressionStmt -> . NAME EQUALS expressionStmt
    (50) expressionStmt -> . expressionStmt EQUALEQUAL NAME
    (51) expressionStmt -> . NAME

    NAME            shift and go to state 106

    expressionStmt                 shift and go to state 107

state 96

    (55) iterationStmt -> DO statement . WHILE LPAREN expressionStmt RPAREN SCOLON

    WHILE           shift and go to state 108


state 97

    (56) iterationStmt -> FOR LPAREN . varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement
    (6) varDeclaration -> . typeSpecifier NAME SCOLON
    (7) varDeclaration -> . typeSpecifier NAME EQUALS expressionStmt SCOLON
    (8) varDeclaration -> . typeSpecifier NAME EQUALS NUMBER
    (9) varDeclaration -> . typeSpecifier NAME EQUALS NAME
    (10) typeSpecifier -> . INT
    (11) typeSpecifier -> . BOOL
    (12) typeSpecifier -> . CHAR
    (13) typeSpecifier -> . FLOAT

    INT             shift and go to state 28
    BOOL            shift and go to state 10
    CHAR            shift and go to state 11
    FLOAT           shift and go to state 29

    varDeclaration                 shift and go to state 109
    typeSpecifier                  shift and go to state 6

state 98

    (15) funcdef -> INT NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN .

    VOID            reduce using rule 15 (funcdef -> INT NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN .)
    INT             reduce using rule 15 (funcdef -> INT NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN .)
    FLOAT           reduce using rule 15 (funcdef -> INT NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN .)
    BOOL            reduce using rule 15 (funcdef -> INT NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN .)
    CHAR            reduce using rule 15 (funcdef -> INT NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN .)
    $end            reduce using rule 15 (funcdef -> INT NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN .)


state 99

    (17) funcdef -> FLOAT NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN .

    VOID            reduce using rule 17 (funcdef -> FLOAT NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN .)
    INT             reduce using rule 17 (funcdef -> FLOAT NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN .)
    FLOAT           reduce using rule 17 (funcdef -> FLOAT NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN .)
    BOOL            reduce using rule 17 (funcdef -> FLOAT NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN .)
    CHAR            reduce using rule 17 (funcdef -> FLOAT NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN .)
    $end            reduce using rule 17 (funcdef -> FLOAT NAME LPAREN parameters RPAREN LFPAREN funcbody RFPAREN .)


state 100

    (29) cstatement -> LFPAREN blockitemlist RFPAREN .

    SCOLON          reduce using rule 29 (cstatement -> LFPAREN blockitemlist RFPAREN .)
    NAME            reduce using rule 29 (cstatement -> LFPAREN blockitemlist RFPAREN .)
    RETURN          reduce using rule 29 (cstatement -> LFPAREN blockitemlist RFPAREN .)
    LFPAREN         reduce using rule 29 (cstatement -> LFPAREN blockitemlist RFPAREN .)
    IF              reduce using rule 29 (cstatement -> LFPAREN blockitemlist RFPAREN .)
    WHILE           reduce using rule 29 (cstatement -> LFPAREN blockitemlist RFPAREN .)
    DO              reduce using rule 29 (cstatement -> LFPAREN blockitemlist RFPAREN .)
    FOR             reduce using rule 29 (cstatement -> LFPAREN blockitemlist RFPAREN .)
    INT             reduce using rule 29 (cstatement -> LFPAREN blockitemlist RFPAREN .)
    BOOL            reduce using rule 29 (cstatement -> LFPAREN blockitemlist RFPAREN .)
    CHAR            reduce using rule 29 (cstatement -> LFPAREN blockitemlist RFPAREN .)
    FLOAT           reduce using rule 29 (cstatement -> LFPAREN blockitemlist RFPAREN .)
    RFPAREN         reduce using rule 29 (cstatement -> LFPAREN blockitemlist RFPAREN .)
    ELSE            reduce using rule 29 (cstatement -> LFPAREN blockitemlist RFPAREN .)


state 101

    (25) blockitemlist -> blockitemlist blockitem .

    RFPAREN         reduce using rule 25 (blockitemlist -> blockitemlist blockitem .)
    NAME            reduce using rule 25 (blockitemlist -> blockitemlist blockitem .)
    RETURN          reduce using rule 25 (blockitemlist -> blockitemlist blockitem .)
    LFPAREN         reduce using rule 25 (blockitemlist -> blockitemlist blockitem .)
    IF              reduce using rule 25 (blockitemlist -> blockitemlist blockitem .)
    WHILE           reduce using rule 25 (blockitemlist -> blockitemlist blockitem .)
    DO              reduce using rule 25 (blockitemlist -> blockitemlist blockitem .)
    FOR             reduce using rule 25 (blockitemlist -> blockitemlist blockitem .)
    INT             reduce using rule 25 (blockitemlist -> blockitemlist blockitem .)
    BOOL            reduce using rule 25 (blockitemlist -> blockitemlist blockitem .)
    CHAR            reduce using rule 25 (blockitemlist -> blockitemlist blockitem .)
    FLOAT           reduce using rule 25 (blockitemlist -> blockitemlist blockitem .)


state 102

    (23) funcbody -> statement SCOLON funcbody .

    RFPAREN         reduce using rule 23 (funcbody -> statement SCOLON funcbody .)


state 103

    (36) statement -> expressionStmt SCOLON statement .

    SCOLON          reduce using rule 36 (statement -> expressionStmt SCOLON statement .)
    NAME            reduce using rule 36 (statement -> expressionStmt SCOLON statement .)
    RETURN          reduce using rule 36 (statement -> expressionStmt SCOLON statement .)
    LFPAREN         reduce using rule 36 (statement -> expressionStmt SCOLON statement .)
    IF              reduce using rule 36 (statement -> expressionStmt SCOLON statement .)
    WHILE           reduce using rule 36 (statement -> expressionStmt SCOLON statement .)
    DO              reduce using rule 36 (statement -> expressionStmt SCOLON statement .)
    FOR             reduce using rule 36 (statement -> expressionStmt SCOLON statement .)
    INT             reduce using rule 36 (statement -> expressionStmt SCOLON statement .)
    BOOL            reduce using rule 36 (statement -> expressionStmt SCOLON statement .)
    CHAR            reduce using rule 36 (statement -> expressionStmt SCOLON statement .)
    FLOAT           reduce using rule 36 (statement -> expressionStmt SCOLON statement .)
    RFPAREN         reduce using rule 36 (statement -> expressionStmt SCOLON statement .)
    ELSE            reduce using rule 36 (statement -> expressionStmt SCOLON statement .)


state 104

    (38) statement -> RETURN NAME SCOLON .

    SCOLON          reduce using rule 38 (statement -> RETURN NAME SCOLON .)
    NAME            reduce using rule 38 (statement -> RETURN NAME SCOLON .)
    RETURN          reduce using rule 38 (statement -> RETURN NAME SCOLON .)
    LFPAREN         reduce using rule 38 (statement -> RETURN NAME SCOLON .)
    IF              reduce using rule 38 (statement -> RETURN NAME SCOLON .)
    WHILE           reduce using rule 38 (statement -> RETURN NAME SCOLON .)
    DO              reduce using rule 38 (statement -> RETURN NAME SCOLON .)
    FOR             reduce using rule 38 (statement -> RETURN NAME SCOLON .)
    INT             reduce using rule 38 (statement -> RETURN NAME SCOLON .)
    BOOL            reduce using rule 38 (statement -> RETURN NAME SCOLON .)
    CHAR            reduce using rule 38 (statement -> RETURN NAME SCOLON .)
    FLOAT           reduce using rule 38 (statement -> RETURN NAME SCOLON .)
    RFPAREN         reduce using rule 38 (statement -> RETURN NAME SCOLON .)
    ELSE            reduce using rule 38 (statement -> RETURN NAME SCOLON .)


state 105

    (52) selectionStmt -> IF LPAREN expressionStmt . RPAREN statement ELSE statement
    (53) selectionStmt -> IF LPAREN expressionStmt . RPAREN statement
    (50) expressionStmt -> expressionStmt . EQUALEQUAL NAME

    RPAREN          shift and go to state 110
    EQUALEQUAL      shift and go to state 43


state 106

    (39) expressionStmt -> NAME . PLUS NAME
    (40) expressionStmt -> NAME . MINUS NAME
    (41) expressionStmt -> NAME . TIMES NAME
    (42) expressionStmt -> NAME . DIVIDES NAME
    (43) expressionStmt -> NAME . EQUALS NAME
    (44) expressionStmt -> NAME . GREATERTHAN NAME
    (45) expressionStmt -> NAME . LESSTHAN NAME
    (46) expressionStmt -> NAME . GREATEQ NAME
    (47) expressionStmt -> NAME . MODULUS NAME
    (48) expressionStmt -> NAME . LESSEQ NAME
    (49) expressionStmt -> NAME . EQUALS expressionStmt
    (51) expressionStmt -> NAME .

    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDES         shift and go to state 36
    EQUALS          shift and go to state 32
    GREATERTHAN     shift and go to state 37
    LESSTHAN        shift and go to state 38
    GREATEQ         shift and go to state 39
    MODULUS         shift and go to state 40
    LESSEQ          shift and go to state 41
    RPAREN          reduce using rule 51 (expressionStmt -> NAME .)
    EQUALEQUAL      reduce using rule 51 (expressionStmt -> NAME .)


state 107

    (54) iterationStmt -> WHILE LPAREN expressionStmt . RPAREN statement
    (50) expressionStmt -> expressionStmt . EQUALEQUAL NAME

    RPAREN          shift and go to state 111
    EQUALEQUAL      shift and go to state 43


state 108

    (55) iterationStmt -> DO statement WHILE . LPAREN expressionStmt RPAREN SCOLON

    LPAREN          shift and go to state 112


state 109

    (56) iterationStmt -> FOR LPAREN varDeclaration . SCOLON forcondition SCOLON forchange RPAREN statement

    SCOLON          shift and go to state 113


state 110

    (52) selectionStmt -> IF LPAREN expressionStmt RPAREN . statement ELSE statement
    (53) selectionStmt -> IF LPAREN expressionStmt RPAREN . statement
    (30) statement -> . cstatement
    (31) statement -> . selectionStmt
    (32) statement -> . iterationStmt
    (33) statement -> . NAME SCOLON
    (34) statement -> . NAME statement
    (35) statement -> . varDeclaration statement
    (36) statement -> . expressionStmt SCOLON statement
    (37) statement -> . expressionStmt SCOLON
    (38) statement -> . RETURN NAME SCOLON
    (28) cstatement -> . LFPAREN RFPAREN
    (29) cstatement -> . LFPAREN blockitemlist RFPAREN
    (52) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement ELSE statement
    (53) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement
    (54) iterationStmt -> . WHILE LPAREN expressionStmt RPAREN statement
    (55) iterationStmt -> . DO statement WHILE LPAREN expressionStmt RPAREN SCOLON
    (56) iterationStmt -> . FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement
    (6) varDeclaration -> . typeSpecifier NAME SCOLON
    (7) varDeclaration -> . typeSpecifier NAME EQUALS expressionStmt SCOLON
    (8) varDeclaration -> . typeSpecifier NAME EQUALS NUMBER
    (9) varDeclaration -> . typeSpecifier NAME EQUALS NAME
    (39) expressionStmt -> . NAME PLUS NAME
    (40) expressionStmt -> . NAME MINUS NAME
    (41) expressionStmt -> . NAME TIMES NAME
    (42) expressionStmt -> . NAME DIVIDES NAME
    (43) expressionStmt -> . NAME EQUALS NAME
    (44) expressionStmt -> . NAME GREATERTHAN NAME
    (45) expressionStmt -> . NAME LESSTHAN NAME
    (46) expressionStmt -> . NAME GREATEQ NAME
    (47) expressionStmt -> . NAME MODULUS NAME
    (48) expressionStmt -> . NAME LESSEQ NAME
    (49) expressionStmt -> . NAME EQUALS expressionStmt
    (50) expressionStmt -> . expressionStmt EQUALEQUAL NAME
    (51) expressionStmt -> . NAME
    (10) typeSpecifier -> . INT
    (11) typeSpecifier -> . BOOL
    (12) typeSpecifier -> . CHAR
    (13) typeSpecifier -> . FLOAT

    NAME            shift and go to state 64
    RETURN          shift and go to state 73
    LFPAREN         shift and go to state 65
    IF              shift and go to state 74
    WHILE           shift and go to state 75
    DO              shift and go to state 76
    FOR             shift and go to state 77
    INT             shift and go to state 28
    BOOL            shift and go to state 10
    CHAR            shift and go to state 11
    FLOAT           shift and go to state 29

    expressionStmt                 shift and go to state 72
    statement                      shift and go to state 114
    cstatement                     shift and go to state 68
    selectionStmt                  shift and go to state 69
    iterationStmt                  shift and go to state 70
    varDeclaration                 shift and go to state 71
    typeSpecifier                  shift and go to state 6

state 111

    (54) iterationStmt -> WHILE LPAREN expressionStmt RPAREN . statement
    (30) statement -> . cstatement
    (31) statement -> . selectionStmt
    (32) statement -> . iterationStmt
    (33) statement -> . NAME SCOLON
    (34) statement -> . NAME statement
    (35) statement -> . varDeclaration statement
    (36) statement -> . expressionStmt SCOLON statement
    (37) statement -> . expressionStmt SCOLON
    (38) statement -> . RETURN NAME SCOLON
    (28) cstatement -> . LFPAREN RFPAREN
    (29) cstatement -> . LFPAREN blockitemlist RFPAREN
    (52) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement ELSE statement
    (53) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement
    (54) iterationStmt -> . WHILE LPAREN expressionStmt RPAREN statement
    (55) iterationStmt -> . DO statement WHILE LPAREN expressionStmt RPAREN SCOLON
    (56) iterationStmt -> . FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement
    (6) varDeclaration -> . typeSpecifier NAME SCOLON
    (7) varDeclaration -> . typeSpecifier NAME EQUALS expressionStmt SCOLON
    (8) varDeclaration -> . typeSpecifier NAME EQUALS NUMBER
    (9) varDeclaration -> . typeSpecifier NAME EQUALS NAME
    (39) expressionStmt -> . NAME PLUS NAME
    (40) expressionStmt -> . NAME MINUS NAME
    (41) expressionStmt -> . NAME TIMES NAME
    (42) expressionStmt -> . NAME DIVIDES NAME
    (43) expressionStmt -> . NAME EQUALS NAME
    (44) expressionStmt -> . NAME GREATERTHAN NAME
    (45) expressionStmt -> . NAME LESSTHAN NAME
    (46) expressionStmt -> . NAME GREATEQ NAME
    (47) expressionStmt -> . NAME MODULUS NAME
    (48) expressionStmt -> . NAME LESSEQ NAME
    (49) expressionStmt -> . NAME EQUALS expressionStmt
    (50) expressionStmt -> . expressionStmt EQUALEQUAL NAME
    (51) expressionStmt -> . NAME
    (10) typeSpecifier -> . INT
    (11) typeSpecifier -> . BOOL
    (12) typeSpecifier -> . CHAR
    (13) typeSpecifier -> . FLOAT

    NAME            shift and go to state 64
    RETURN          shift and go to state 73
    LFPAREN         shift and go to state 65
    IF              shift and go to state 74
    WHILE           shift and go to state 75
    DO              shift and go to state 76
    FOR             shift and go to state 77
    INT             shift and go to state 28
    BOOL            shift and go to state 10
    CHAR            shift and go to state 11
    FLOAT           shift and go to state 29

    expressionStmt                 shift and go to state 72
    statement                      shift and go to state 115
    cstatement                     shift and go to state 68
    selectionStmt                  shift and go to state 69
    iterationStmt                  shift and go to state 70
    varDeclaration                 shift and go to state 71
    typeSpecifier                  shift and go to state 6

state 112

    (55) iterationStmt -> DO statement WHILE LPAREN . expressionStmt RPAREN SCOLON
    (39) expressionStmt -> . NAME PLUS NAME
    (40) expressionStmt -> . NAME MINUS NAME
    (41) expressionStmt -> . NAME TIMES NAME
    (42) expressionStmt -> . NAME DIVIDES NAME
    (43) expressionStmt -> . NAME EQUALS NAME
    (44) expressionStmt -> . NAME GREATERTHAN NAME
    (45) expressionStmt -> . NAME LESSTHAN NAME
    (46) expressionStmt -> . NAME GREATEQ NAME
    (47) expressionStmt -> . NAME MODULUS NAME
    (48) expressionStmt -> . NAME LESSEQ NAME
    (49) expressionStmt -> . NAME EQUALS expressionStmt
    (50) expressionStmt -> . expressionStmt EQUALEQUAL NAME
    (51) expressionStmt -> . NAME

    NAME            shift and go to state 106

    expressionStmt                 shift and go to state 116

state 113

    (56) iterationStmt -> FOR LPAREN varDeclaration SCOLON . forcondition SCOLON forchange RPAREN statement
    (57) forcondition -> . NAME EQUALS NAME
    (58) forcondition -> . NAME GREATERTHAN NAME
    (59) forcondition -> . NAME LESSTHAN NAME
    (60) forcondition -> . NAME GREATEQ NAME
    (61) forcondition -> . NAME LESSEQ NAME

    NAME            shift and go to state 118

    forcondition                   shift and go to state 117

state 114

    (52) selectionStmt -> IF LPAREN expressionStmt RPAREN statement . ELSE statement
    (53) selectionStmt -> IF LPAREN expressionStmt RPAREN statement .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 119
    SCOLON          reduce using rule 53 (selectionStmt -> IF LPAREN expressionStmt RPAREN statement .)
    NAME            reduce using rule 53 (selectionStmt -> IF LPAREN expressionStmt RPAREN statement .)
    RETURN          reduce using rule 53 (selectionStmt -> IF LPAREN expressionStmt RPAREN statement .)
    LFPAREN         reduce using rule 53 (selectionStmt -> IF LPAREN expressionStmt RPAREN statement .)
    IF              reduce using rule 53 (selectionStmt -> IF LPAREN expressionStmt RPAREN statement .)
    WHILE           reduce using rule 53 (selectionStmt -> IF LPAREN expressionStmt RPAREN statement .)
    DO              reduce using rule 53 (selectionStmt -> IF LPAREN expressionStmt RPAREN statement .)
    FOR             reduce using rule 53 (selectionStmt -> IF LPAREN expressionStmt RPAREN statement .)
    INT             reduce using rule 53 (selectionStmt -> IF LPAREN expressionStmt RPAREN statement .)
    BOOL            reduce using rule 53 (selectionStmt -> IF LPAREN expressionStmt RPAREN statement .)
    CHAR            reduce using rule 53 (selectionStmt -> IF LPAREN expressionStmt RPAREN statement .)
    FLOAT           reduce using rule 53 (selectionStmt -> IF LPAREN expressionStmt RPAREN statement .)
    RFPAREN         reduce using rule 53 (selectionStmt -> IF LPAREN expressionStmt RPAREN statement .)

  ! ELSE            [ reduce using rule 53 (selectionStmt -> IF LPAREN expressionStmt RPAREN statement .) ]


state 115

    (54) iterationStmt -> WHILE LPAREN expressionStmt RPAREN statement .

    SCOLON          reduce using rule 54 (iterationStmt -> WHILE LPAREN expressionStmt RPAREN statement .)
    NAME            reduce using rule 54 (iterationStmt -> WHILE LPAREN expressionStmt RPAREN statement .)
    RETURN          reduce using rule 54 (iterationStmt -> WHILE LPAREN expressionStmt RPAREN statement .)
    LFPAREN         reduce using rule 54 (iterationStmt -> WHILE LPAREN expressionStmt RPAREN statement .)
    IF              reduce using rule 54 (iterationStmt -> WHILE LPAREN expressionStmt RPAREN statement .)
    WHILE           reduce using rule 54 (iterationStmt -> WHILE LPAREN expressionStmt RPAREN statement .)
    DO              reduce using rule 54 (iterationStmt -> WHILE LPAREN expressionStmt RPAREN statement .)
    FOR             reduce using rule 54 (iterationStmt -> WHILE LPAREN expressionStmt RPAREN statement .)
    INT             reduce using rule 54 (iterationStmt -> WHILE LPAREN expressionStmt RPAREN statement .)
    BOOL            reduce using rule 54 (iterationStmt -> WHILE LPAREN expressionStmt RPAREN statement .)
    CHAR            reduce using rule 54 (iterationStmt -> WHILE LPAREN expressionStmt RPAREN statement .)
    FLOAT           reduce using rule 54 (iterationStmt -> WHILE LPAREN expressionStmt RPAREN statement .)
    RFPAREN         reduce using rule 54 (iterationStmt -> WHILE LPAREN expressionStmt RPAREN statement .)
    ELSE            reduce using rule 54 (iterationStmt -> WHILE LPAREN expressionStmt RPAREN statement .)


state 116

    (55) iterationStmt -> DO statement WHILE LPAREN expressionStmt . RPAREN SCOLON
    (50) expressionStmt -> expressionStmt . EQUALEQUAL NAME

    RPAREN          shift and go to state 120
    EQUALEQUAL      shift and go to state 43


state 117

    (56) iterationStmt -> FOR LPAREN varDeclaration SCOLON forcondition . SCOLON forchange RPAREN statement

    SCOLON          shift and go to state 121


state 118

    (57) forcondition -> NAME . EQUALS NAME
    (58) forcondition -> NAME . GREATERTHAN NAME
    (59) forcondition -> NAME . LESSTHAN NAME
    (60) forcondition -> NAME . GREATEQ NAME
    (61) forcondition -> NAME . LESSEQ NAME

    EQUALS          shift and go to state 122
    GREATERTHAN     shift and go to state 123
    LESSTHAN        shift and go to state 124
    GREATEQ         shift and go to state 125
    LESSEQ          shift and go to state 126


state 119

    (52) selectionStmt -> IF LPAREN expressionStmt RPAREN statement ELSE . statement
    (30) statement -> . cstatement
    (31) statement -> . selectionStmt
    (32) statement -> . iterationStmt
    (33) statement -> . NAME SCOLON
    (34) statement -> . NAME statement
    (35) statement -> . varDeclaration statement
    (36) statement -> . expressionStmt SCOLON statement
    (37) statement -> . expressionStmt SCOLON
    (38) statement -> . RETURN NAME SCOLON
    (28) cstatement -> . LFPAREN RFPAREN
    (29) cstatement -> . LFPAREN blockitemlist RFPAREN
    (52) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement ELSE statement
    (53) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement
    (54) iterationStmt -> . WHILE LPAREN expressionStmt RPAREN statement
    (55) iterationStmt -> . DO statement WHILE LPAREN expressionStmt RPAREN SCOLON
    (56) iterationStmt -> . FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement
    (6) varDeclaration -> . typeSpecifier NAME SCOLON
    (7) varDeclaration -> . typeSpecifier NAME EQUALS expressionStmt SCOLON
    (8) varDeclaration -> . typeSpecifier NAME EQUALS NUMBER
    (9) varDeclaration -> . typeSpecifier NAME EQUALS NAME
    (39) expressionStmt -> . NAME PLUS NAME
    (40) expressionStmt -> . NAME MINUS NAME
    (41) expressionStmt -> . NAME TIMES NAME
    (42) expressionStmt -> . NAME DIVIDES NAME
    (43) expressionStmt -> . NAME EQUALS NAME
    (44) expressionStmt -> . NAME GREATERTHAN NAME
    (45) expressionStmt -> . NAME LESSTHAN NAME
    (46) expressionStmt -> . NAME GREATEQ NAME
    (47) expressionStmt -> . NAME MODULUS NAME
    (48) expressionStmt -> . NAME LESSEQ NAME
    (49) expressionStmt -> . NAME EQUALS expressionStmt
    (50) expressionStmt -> . expressionStmt EQUALEQUAL NAME
    (51) expressionStmt -> . NAME
    (10) typeSpecifier -> . INT
    (11) typeSpecifier -> . BOOL
    (12) typeSpecifier -> . CHAR
    (13) typeSpecifier -> . FLOAT

    NAME            shift and go to state 64
    RETURN          shift and go to state 73
    LFPAREN         shift and go to state 65
    IF              shift and go to state 74
    WHILE           shift and go to state 75
    DO              shift and go to state 76
    FOR             shift and go to state 77
    INT             shift and go to state 28
    BOOL            shift and go to state 10
    CHAR            shift and go to state 11
    FLOAT           shift and go to state 29

    expressionStmt                 shift and go to state 72
    statement                      shift and go to state 127
    cstatement                     shift and go to state 68
    selectionStmt                  shift and go to state 69
    iterationStmt                  shift and go to state 70
    varDeclaration                 shift and go to state 71
    typeSpecifier                  shift and go to state 6

state 120

    (55) iterationStmt -> DO statement WHILE LPAREN expressionStmt RPAREN . SCOLON

    SCOLON          shift and go to state 128


state 121

    (56) iterationStmt -> FOR LPAREN varDeclaration SCOLON forcondition SCOLON . forchange RPAREN statement
    (62) forchange -> . NAME PLUS PLUS
    (63) forchange -> . NAME MINUS MINUS
    (64) forchange -> . expressionStmt
    (39) expressionStmt -> . NAME PLUS NAME
    (40) expressionStmt -> . NAME MINUS NAME
    (41) expressionStmt -> . NAME TIMES NAME
    (42) expressionStmt -> . NAME DIVIDES NAME
    (43) expressionStmt -> . NAME EQUALS NAME
    (44) expressionStmt -> . NAME GREATERTHAN NAME
    (45) expressionStmt -> . NAME LESSTHAN NAME
    (46) expressionStmt -> . NAME GREATEQ NAME
    (47) expressionStmt -> . NAME MODULUS NAME
    (48) expressionStmt -> . NAME LESSEQ NAME
    (49) expressionStmt -> . NAME EQUALS expressionStmt
    (50) expressionStmt -> . expressionStmt EQUALEQUAL NAME
    (51) expressionStmt -> . NAME

    NAME            shift and go to state 130

    forchange                      shift and go to state 129
    expressionStmt                 shift and go to state 131

state 122

    (57) forcondition -> NAME EQUALS . NAME

    NAME            shift and go to state 132


state 123

    (58) forcondition -> NAME GREATERTHAN . NAME

    NAME            shift and go to state 133


state 124

    (59) forcondition -> NAME LESSTHAN . NAME

    NAME            shift and go to state 134


state 125

    (60) forcondition -> NAME GREATEQ . NAME

    NAME            shift and go to state 135


state 126

    (61) forcondition -> NAME LESSEQ . NAME

    NAME            shift and go to state 136


state 127

    (52) selectionStmt -> IF LPAREN expressionStmt RPAREN statement ELSE statement .

    SCOLON          reduce using rule 52 (selectionStmt -> IF LPAREN expressionStmt RPAREN statement ELSE statement .)
    NAME            reduce using rule 52 (selectionStmt -> IF LPAREN expressionStmt RPAREN statement ELSE statement .)
    RETURN          reduce using rule 52 (selectionStmt -> IF LPAREN expressionStmt RPAREN statement ELSE statement .)
    LFPAREN         reduce using rule 52 (selectionStmt -> IF LPAREN expressionStmt RPAREN statement ELSE statement .)
    IF              reduce using rule 52 (selectionStmt -> IF LPAREN expressionStmt RPAREN statement ELSE statement .)
    WHILE           reduce using rule 52 (selectionStmt -> IF LPAREN expressionStmt RPAREN statement ELSE statement .)
    DO              reduce using rule 52 (selectionStmt -> IF LPAREN expressionStmt RPAREN statement ELSE statement .)
    FOR             reduce using rule 52 (selectionStmt -> IF LPAREN expressionStmt RPAREN statement ELSE statement .)
    INT             reduce using rule 52 (selectionStmt -> IF LPAREN expressionStmt RPAREN statement ELSE statement .)
    BOOL            reduce using rule 52 (selectionStmt -> IF LPAREN expressionStmt RPAREN statement ELSE statement .)
    CHAR            reduce using rule 52 (selectionStmt -> IF LPAREN expressionStmt RPAREN statement ELSE statement .)
    FLOAT           reduce using rule 52 (selectionStmt -> IF LPAREN expressionStmt RPAREN statement ELSE statement .)
    RFPAREN         reduce using rule 52 (selectionStmt -> IF LPAREN expressionStmt RPAREN statement ELSE statement .)
    ELSE            reduce using rule 52 (selectionStmt -> IF LPAREN expressionStmt RPAREN statement ELSE statement .)


state 128

    (55) iterationStmt -> DO statement WHILE LPAREN expressionStmt RPAREN SCOLON .

    SCOLON          reduce using rule 55 (iterationStmt -> DO statement WHILE LPAREN expressionStmt RPAREN SCOLON .)
    NAME            reduce using rule 55 (iterationStmt -> DO statement WHILE LPAREN expressionStmt RPAREN SCOLON .)
    RETURN          reduce using rule 55 (iterationStmt -> DO statement WHILE LPAREN expressionStmt RPAREN SCOLON .)
    LFPAREN         reduce using rule 55 (iterationStmt -> DO statement WHILE LPAREN expressionStmt RPAREN SCOLON .)
    IF              reduce using rule 55 (iterationStmt -> DO statement WHILE LPAREN expressionStmt RPAREN SCOLON .)
    WHILE           reduce using rule 55 (iterationStmt -> DO statement WHILE LPAREN expressionStmt RPAREN SCOLON .)
    DO              reduce using rule 55 (iterationStmt -> DO statement WHILE LPAREN expressionStmt RPAREN SCOLON .)
    FOR             reduce using rule 55 (iterationStmt -> DO statement WHILE LPAREN expressionStmt RPAREN SCOLON .)
    INT             reduce using rule 55 (iterationStmt -> DO statement WHILE LPAREN expressionStmt RPAREN SCOLON .)
    BOOL            reduce using rule 55 (iterationStmt -> DO statement WHILE LPAREN expressionStmt RPAREN SCOLON .)
    CHAR            reduce using rule 55 (iterationStmt -> DO statement WHILE LPAREN expressionStmt RPAREN SCOLON .)
    FLOAT           reduce using rule 55 (iterationStmt -> DO statement WHILE LPAREN expressionStmt RPAREN SCOLON .)
    RFPAREN         reduce using rule 55 (iterationStmt -> DO statement WHILE LPAREN expressionStmt RPAREN SCOLON .)
    ELSE            reduce using rule 55 (iterationStmt -> DO statement WHILE LPAREN expressionStmt RPAREN SCOLON .)


state 129

    (56) iterationStmt -> FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange . RPAREN statement

    RPAREN          shift and go to state 137


state 130

    (62) forchange -> NAME . PLUS PLUS
    (63) forchange -> NAME . MINUS MINUS
    (39) expressionStmt -> NAME . PLUS NAME
    (40) expressionStmt -> NAME . MINUS NAME
    (41) expressionStmt -> NAME . TIMES NAME
    (42) expressionStmt -> NAME . DIVIDES NAME
    (43) expressionStmt -> NAME . EQUALS NAME
    (44) expressionStmt -> NAME . GREATERTHAN NAME
    (45) expressionStmt -> NAME . LESSTHAN NAME
    (46) expressionStmt -> NAME . GREATEQ NAME
    (47) expressionStmt -> NAME . MODULUS NAME
    (48) expressionStmt -> NAME . LESSEQ NAME
    (49) expressionStmt -> NAME . EQUALS expressionStmt
    (51) expressionStmt -> NAME .

    PLUS            shift and go to state 138
    MINUS           shift and go to state 139
    TIMES           shift and go to state 35
    DIVIDES         shift and go to state 36
    EQUALS          shift and go to state 32
    GREATERTHAN     shift and go to state 37
    LESSTHAN        shift and go to state 38
    GREATEQ         shift and go to state 39
    MODULUS         shift and go to state 40
    LESSEQ          shift and go to state 41
    EQUALEQUAL      reduce using rule 51 (expressionStmt -> NAME .)
    RPAREN          reduce using rule 51 (expressionStmt -> NAME .)


state 131

    (64) forchange -> expressionStmt .
    (50) expressionStmt -> expressionStmt . EQUALEQUAL NAME

    RPAREN          reduce using rule 64 (forchange -> expressionStmt .)
    EQUALEQUAL      shift and go to state 43


state 132

    (57) forcondition -> NAME EQUALS NAME .

    SCOLON          reduce using rule 57 (forcondition -> NAME EQUALS NAME .)


state 133

    (58) forcondition -> NAME GREATERTHAN NAME .

    SCOLON          reduce using rule 58 (forcondition -> NAME GREATERTHAN NAME .)


state 134

    (59) forcondition -> NAME LESSTHAN NAME .

    SCOLON          reduce using rule 59 (forcondition -> NAME LESSTHAN NAME .)


state 135

    (60) forcondition -> NAME GREATEQ NAME .

    SCOLON          reduce using rule 60 (forcondition -> NAME GREATEQ NAME .)


state 136

    (61) forcondition -> NAME LESSEQ NAME .

    SCOLON          reduce using rule 61 (forcondition -> NAME LESSEQ NAME .)


state 137

    (56) iterationStmt -> FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN . statement
    (30) statement -> . cstatement
    (31) statement -> . selectionStmt
    (32) statement -> . iterationStmt
    (33) statement -> . NAME SCOLON
    (34) statement -> . NAME statement
    (35) statement -> . varDeclaration statement
    (36) statement -> . expressionStmt SCOLON statement
    (37) statement -> . expressionStmt SCOLON
    (38) statement -> . RETURN NAME SCOLON
    (28) cstatement -> . LFPAREN RFPAREN
    (29) cstatement -> . LFPAREN blockitemlist RFPAREN
    (52) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement ELSE statement
    (53) selectionStmt -> . IF LPAREN expressionStmt RPAREN statement
    (54) iterationStmt -> . WHILE LPAREN expressionStmt RPAREN statement
    (55) iterationStmt -> . DO statement WHILE LPAREN expressionStmt RPAREN SCOLON
    (56) iterationStmt -> . FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement
    (6) varDeclaration -> . typeSpecifier NAME SCOLON
    (7) varDeclaration -> . typeSpecifier NAME EQUALS expressionStmt SCOLON
    (8) varDeclaration -> . typeSpecifier NAME EQUALS NUMBER
    (9) varDeclaration -> . typeSpecifier NAME EQUALS NAME
    (39) expressionStmt -> . NAME PLUS NAME
    (40) expressionStmt -> . NAME MINUS NAME
    (41) expressionStmt -> . NAME TIMES NAME
    (42) expressionStmt -> . NAME DIVIDES NAME
    (43) expressionStmt -> . NAME EQUALS NAME
    (44) expressionStmt -> . NAME GREATERTHAN NAME
    (45) expressionStmt -> . NAME LESSTHAN NAME
    (46) expressionStmt -> . NAME GREATEQ NAME
    (47) expressionStmt -> . NAME MODULUS NAME
    (48) expressionStmt -> . NAME LESSEQ NAME
    (49) expressionStmt -> . NAME EQUALS expressionStmt
    (50) expressionStmt -> . expressionStmt EQUALEQUAL NAME
    (51) expressionStmt -> . NAME
    (10) typeSpecifier -> . INT
    (11) typeSpecifier -> . BOOL
    (12) typeSpecifier -> . CHAR
    (13) typeSpecifier -> . FLOAT

    NAME            shift and go to state 64
    RETURN          shift and go to state 73
    LFPAREN         shift and go to state 65
    IF              shift and go to state 74
    WHILE           shift and go to state 75
    DO              shift and go to state 76
    FOR             shift and go to state 77
    INT             shift and go to state 28
    BOOL            shift and go to state 10
    CHAR            shift and go to state 11
    FLOAT           shift and go to state 29

    varDeclaration                 shift and go to state 71
    statement                      shift and go to state 140
    cstatement                     shift and go to state 68
    selectionStmt                  shift and go to state 69
    iterationStmt                  shift and go to state 70
    expressionStmt                 shift and go to state 72
    typeSpecifier                  shift and go to state 6

state 138

    (62) forchange -> NAME PLUS . PLUS
    (39) expressionStmt -> NAME PLUS . NAME

    PLUS            shift and go to state 141
    NAME            shift and go to state 50


state 139

    (63) forchange -> NAME MINUS . MINUS
    (40) expressionStmt -> NAME MINUS . NAME

    MINUS           shift and go to state 142
    NAME            shift and go to state 51


state 140

    (56) iterationStmt -> FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement .

    SCOLON          reduce using rule 56 (iterationStmt -> FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement .)
    NAME            reduce using rule 56 (iterationStmt -> FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement .)
    RETURN          reduce using rule 56 (iterationStmt -> FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement .)
    LFPAREN         reduce using rule 56 (iterationStmt -> FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement .)
    IF              reduce using rule 56 (iterationStmt -> FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement .)
    WHILE           reduce using rule 56 (iterationStmt -> FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement .)
    DO              reduce using rule 56 (iterationStmt -> FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement .)
    FOR             reduce using rule 56 (iterationStmt -> FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement .)
    INT             reduce using rule 56 (iterationStmt -> FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement .)
    BOOL            reduce using rule 56 (iterationStmt -> FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement .)
    CHAR            reduce using rule 56 (iterationStmt -> FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement .)
    FLOAT           reduce using rule 56 (iterationStmt -> FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement .)
    RFPAREN         reduce using rule 56 (iterationStmt -> FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement .)
    ELSE            reduce using rule 56 (iterationStmt -> FOR LPAREN varDeclaration SCOLON forcondition SCOLON forchange RPAREN statement .)


state 141

    (62) forchange -> NAME PLUS PLUS .

    RPAREN          reduce using rule 62 (forchange -> NAME PLUS PLUS .)


state 142

    (63) forchange -> NAME MINUS MINUS .

    RPAREN          reduce using rule 63 (forchange -> NAME MINUS MINUS .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for VOID in state 0 resolved as shift
WARNING: shift/reduce conflict for INT in state 0 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 0 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 0 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 0 resolved as shift
WARNING: shift/reduce conflict for VOID in state 2 resolved as shift
WARNING: shift/reduce conflict for INT in state 2 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 2 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 2 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 2 resolved as shift
WARNING: shift/reduce conflict for NAME in state 8 resolved as shift
WARNING: shift/reduce conflict for NAME in state 9 resolved as shift
WARNING: shift/reduce conflict for EQUALEQUAL in state 49 resolved as shift
WARNING: shift/reduce conflict for SCOLON in state 64 resolved as shift
WARNING: shift/reduce conflict for NAME in state 87 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 87 resolved as shift
WARNING: shift/reduce conflict for LFPAREN in state 87 resolved as shift
WARNING: shift/reduce conflict for IF in state 87 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 87 resolved as shift
WARNING: shift/reduce conflict for DO in state 87 resolved as shift
WARNING: shift/reduce conflict for FOR in state 87 resolved as shift
WARNING: shift/reduce conflict for INT in state 87 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 87 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 87 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 87 resolved as shift
WARNING: shift/reduce conflict for NAME in state 92 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 92 resolved as shift
WARNING: shift/reduce conflict for LFPAREN in state 92 resolved as shift
WARNING: shift/reduce conflict for IF in state 92 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 92 resolved as shift
WARNING: shift/reduce conflict for DO in state 92 resolved as shift
WARNING: shift/reduce conflict for FOR in state 92 resolved as shift
WARNING: shift/reduce conflict for INT in state 92 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 92 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 92 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 92 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 114 resolved as shift
WARNING: reduce/reduce conflict in state 2 resolved using rule (start -> declarationList)
WARNING: rejected rule (funcdef -> <empty>) in state 2
WARNING: reduce/reduce conflict in state 22 resolved using rule (varDeclaration -> typeSpecifier NAME EQUALS NAME)
WARNING: rejected rule (expressionStmt -> NAME) in state 22
WARNING: reduce/reduce conflict in state 48 resolved using rule (expressionStmt -> NAME EQUALS NAME)
WARNING: rejected rule (expressionStmt -> NAME) in state 48
